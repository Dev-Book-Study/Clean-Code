# 4ì¥ - ì ì§„ì ì¸ ê°œì„ 

> í”„ë¡œê·¸ë˜ë°ì€ ê³¼í•™ë³´ë‹¤ ê³µì˜ˆì— ê°€ê¹ë‹¤. ê¹¨ë—í•œ ì½”ë“œë¥¼ ì§œë ¤ë©´ ë¨¼ì € ì§€ì €ë¶„í•œ ì½”ë“œë¥¼ ì§  ë’¤ì— ì •ë¦¬í•´ì•¼ í•œë‹¤.
> 

# Args êµ¬í˜„

ëª…ë ¹í–‰ ì¸ìˆ˜ êµ¬ë¬¸ì„ ë¶„ì„í•˜ê¸° ìœ„í•œ í´ë˜ìŠ¤

Marshalling(ë§ˆìƒ¬ë§): ê°ì²´ì˜ ë©”ëª¨ë¦¬ì—ì„œ í‘œí˜„ë°©ì‹ì„ ì €ì¥ ë˜ëŠ” ì „ì†¡ì— ì í•©í•œ ë‹¤ë¥¸ ë°ì´í„° í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ê³¼ì •ì´ë‹¤.

# Args: 1ì°¨ ì´ˆì•ˆ

```java
import java.text.ParseException;
import java.util.*;

public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>();
    private Map<Character, String> stringArgs = new HashMap<Character, String>();
    private Map<Character, Integer> intArgs = new HashMap<Character, Integer>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;

    private enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT
    }

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0)
            return true;
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (isBooleanSchemaElement(elementTail))
            parseBooleanSchemaElement(elementId);
        else if (isStringSchemaElement(elementTail))
            parseStringSchemaElement(elementId);
        else if (isIntegerSchemaElement(elementTail)) {
            parseIntegerSchemaElement(elementId);
        } else {
            throw new ParseException(
                    String.format("Argument: %c has invalid format: %s.",
                            elementId, elementTail),
                    0);
        }
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                    "Bad character:" + elementId + "in Args format: " + schema, 0);
        }
    }

    private void parseBooleanSchemaElement(char elementId) {
        booleanArgs.put(elementId, false);
    }

    private void parseIntegerSchemaElement(char elementId) {
        intArgs.put(elementId, 0);
    }

    private void parseStringSchemaElement(char elementId) {
        stringArgs.put(elementId, "");
    }

    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private boolean isIntegerSchemaElement(String elementTail) {
        return elementTail.equals("#");
    }

    private boolean parseArguments() throws ArgsException {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) throws ArgsException {
        if (arg.startsWith("-"))
            parseElements(arg);
    }

    private void parseElements(String arg) throws ArgsException {
        for (int i = 1; i < arg.length(); i++)
            parseElement(arg.charAt(i));
    }

    private void parseElement(char argChar) throws ArgsException {
        if (setArgument(argChar))
            argsFound.add(argChar);
        else {
            unexpectedArguments.add(argChar);
            errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
            valid = false;
        }
    }

    private boolean setArgument(char argChar) throws ArgsException {
        if (isBooleanArg(argChar))
            setBooleanArg(argChar, true);
        else if (isStringArg(argChar))
            setStringArg(argChar);
        else if (isIntArg(argChar))
            setIntArg(argChar);
        else
            return false;
        return true;
    }

    private boolean isIntArg(char argChar) {
        return intArgs.containsKey(argChar);
    }

    private void setIntArg(char argChar) throws ArgsException {
        currentArgument++;
        String parameter = null;
        try {
            parameter = args[currentArgument];
            intArgs.put(argChar, new Integer(parameter));
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgumentId = argChar;
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (NumberFormatException e) {
            valid = false;
            errorArgumentId = argChar;
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw new ArgsException();
        }
    }

    private void setStringArg(char argChar) throws ArgsException {
        currentArgument++;
        try {
            stringArgs.put(argChar, args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgumentId = argChar;
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }

    private boolean isStringArg(char argChar) {
        return stringArgs.containsKey(argChar);
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBooleanArg(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0)
            return "-[" + schema + "]";
        else
            return "";
    }

    public String errorMessage() throws Exception {
        switch (errorCode) {
            case OK:
                throw new Exception("TILT: Should not get here.");
            case UNEXPECTED_ARGUMENT:
                return unexpectedArgumentMessage();
            case MISSING_STRING:
                return String.format("Could not find string parameter for -%c.",
                        errorArgumentId);
            case INVALID_INTEGER:
                return String.format("Argument -%c expects an integer but was '%s'.",
                        errorArgumentId, errorParameter);
            case MISSING_INTEGER:
                return String.format("Could not find integer parameter for -%c.",
                        errorArgumentId);
        }
        return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");
        return message.toString();
    }

    private boolean falseIfNull(Boolean b) {
        return b != null && b;
    }

    private int zeroIfNull(Integer i) {
        return i == null ? 0 : i;
    }

    private String blankIfNull(String s) {
        return s == null ? "" : s;
    }

    public String getString(char arg) {
        return blankIfNull(stringArgs.get(arg));
    }

    public int getInt(char arg) {
        return zeroIfNull(intArgs.get(arg));
    }

    public boolean getBoolean(char arg) {
        return falseIfNull(booleanArgs.get(arg));
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }

    private class ArgsException extends Exception {
    }
}
```

- ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ê°€ ë„ˆë¬´ ë§ë‹¤.
- `â€œTILTâ€` ì™€ ê°™ì€ ì•Œìˆ˜ ì—†ëŠ” ë¬¸ìì—´ì´ ìˆë‹¤.
- `HashSets`, `TreeSets`, `try-catch-catch` ë¸”ë¡ ë“± ì§€ì €ë¶„í•´ ë³´ì¸ë‹¤.

## Booleanë§Œ ì§€ì›í•˜ëŠ” Args.java

```java
package com.objectmentor.utilities.getopts;

import java.util.*;

public class Args {
    private String schema;
    private String[] args;
    private boolean valid;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>();
    private int numberOfArguments = 0;

    public Args(String schema, String[] args) {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    public boolean isValid() {
        return valid;
    }

    private boolean parse() {
        if (schema.length() == 0 && args.length == 0)
            return true;
        parseSchema();
        parseArguments();
        return unexpectedArguments.size() == 0;
    }

    private boolean parseSchema() {
        for (String element : schema.split(",")) {
            parseSchemaElement(element);
        }
        return true;
    }

    private void parseSchemaElement(String element) {
        if (element.length() == 1) {
            parseBooleanSchemaElement(element);
        }
    }

    private void parseBooleanSchemaElement(String element) {
        char c = element.charAt(0);
        if (Character.isLetter(c)) {
            booleanArgs.put(c, false);
        }
    }

    private boolean parseArguments() {
        for (String arg : args)
            parseArgument(arg);
        return true;
    }

    private void parseArgument(String arg) {
        if (arg.startsWith("-"))
            parseElements(arg);
    }

    private void parseElements(String arg) {
        for (int i = 1; i < arg.length(); i++)
            parseElement(arg.charAt(i));
    }

    private void parseElement(char argChar) {
        if (isBoolean(argChar)) {
            numberOfArguments++;
            setBooleanArg(argChar, true);
        } else
            unexpectedArguments.add(argChar);
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBoolean(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return numberOfArguments;
    }

    public String usage() {
        if (schema.length() > 0)
            return "-[" + schema + "]";
        else
            return "";
    }

    public String errorMessage() {
        if (unexpectedArguments.size() > 0) {
            return unexpectedArgumentMessage();
        } else
            return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");
        return message.toString();
    }

    public boolean getBoolean(char arg) {
        return booleanArgs.get(arg);
    }
}
```

ê°„ê²°í•˜ê³  ë‹¨ìˆœí•˜ë©° ì´í•´í•˜ê¸°ë„ ì‰¬ì› ë‹¤.

í•˜ì§€ë§Œ ì½”ë“œë¥¼ ì˜ ì‚´í´ë³´ë©´ ë‚˜ì¤‘ì— ì—‰ë§ìœ¼ë¡œ ë³€í•´ê°ˆ ì”¨ì•—ì´ ë³´ì¸ë‹¤.

## Booleanê³¼ Stringì„ ì§€ì›í•˜ëŠ” Args.java

```java
package com.objectmentor.utilities.getopts;

import java.text.ParseException;
import java.util.*;

public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>();
    private Map<Character, String> stringArgs = new HashMap<Character, String>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgument = '\0';

    enum ErrorCode {
        OK, MISSING_STRING
    }

    private ErrorCode errorCode = ErrorCode.OK;

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0)
            return true;
        parseSchema();
        parseArguments();
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }
    
    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (isBooleanSchemaElement(elementTail))
            parseBooleanSchemaElement(elementId);
        else if (isStringSchemaElement(elementTail))
            parseStringSchemaElement(elementId);
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                    "Bad character:" + elementId + "in Args format: " + schema, 0);
        }
    }

    private void parseStringSchemaElement(char elementId) {
        stringArgs.put(elementId, "");
    }

    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private void parseBooleanSchemaElement(char elementId) {
        booleanArgs.put(elementId, false);
    }
    //

    // here!
    private boolean parseArguments() {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) {
        if (arg.startsWith("-"))
            parseElements(arg);
    }

    private void parseElements(String arg) {
        for (int i = 1; i < arg.length(); i++)
            parseElement(arg.charAt(i));
    }

    private void parseElement(char argChar) {
        if (setArgument(argChar))
            argsFound.add(argChar);
        else {
            unexpectedArguments.add(argChar);
            valid = false;
        }
    }

    private boolean setArgument(char argChar) {
        boolean set = true;
        if (isBoolean(argChar))
            setBooleanArg(argChar, true);
        else if (isString(argChar))
            setStringArg(argChar, "");
        else
            set = false;
        return set;
    }

    private void setStringArg(char argChar, String s) {
        currentArgument++;
        try {
            stringArgs.put(argChar, args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgument = argChar;
            errorCode = ErrorCode.MISSING_STRING;
        }
    }

    private boolean isString(char argChar) {
        return stringArgs.containsKey(argChar);
    }
    //

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBoolean(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0)
            return "-[" + schema + "]";
        else
            return "";
    }

    public String errorMessage() throws Exception {
        if (unexpectedArguments.size() > 0) {
            return unexpectedArgumentMessage();
        } else
            switch (errorCode) {
                case MISSING_STRING:
                    return String.format("Could not find string parameter for -%c.",
                            errorArgument);
                case OK:
                    throw new Exception("TILT: Should not get here.");
            }
        return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");
        return message.toString();
    }

    public boolean getBoolean(char arg) {
        return falseIfNull(booleanArgs.get(arg));
    }

    private boolean falseIfNull(Boolean b) {
        return b == null ? false : b;
    }

    // here!
    public String getString(char arg) {
        return blankIfNull(stringArgs.get(arg));
    }

    private String blankIfNull(String s) {
        return s == null ? "" : s;
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }
}
```

Stringìœ í˜• ê´€ë ¨ ì½”ë“œ ì¶”ê°€ í›„ ì½”ë“œê°€ ì–´ì§€ëŸ¬ì›Œì¡Œë‹¤. ì´í›„ Integer ì¸ìˆ˜ ìœ í˜•ì„ ì¶”ê°€í•˜ë‹ˆ ì½”ë“œê°€ ì™„ì „íˆ ì—‰ë§ì´ ë˜ì—ˆë‹¤.

# ê·¸ë˜ì„œ ë©ˆì·„ë‹¤.

ì¸ìˆ˜ ìœ í˜•ì„ ë” ì¶”ê°€í•´ì•¼ í–ˆëŠ”ë°, ì½”ë“œê°€ í›¨ì”¬ ë” ë‚˜ë¹ ì§ˆ ê²ƒì´ë¼ëŠ” í™•ì‹ ìœ¼ë¡œ ë¦¬í™í„°ë§ì„ ì‹œì‘í–ˆë‹¤.

ìƒˆ ì¸ìˆ˜ ìœ í˜•ì„ ì¶”ê°€í•˜ë ¤ë©´ ì£¼ìš” ì§€ì  ì„¸ê³³ì—ë‹¤ ì½”ë“œë¥¼ ì¶”ê°€í•´ì•¼ í•œë‹¤ëŠ” ì‚¬ì‹¤ì„ ì•Œì•˜ë‹¤. (parse, get, set)

- ì¸ìˆ˜ ìœ í˜•ì— í•´ë‹¹í•˜ëŠ” HashMapì„ ì„ íƒí•˜ê¸° ìœ„í•´ ìŠ¤í‚¤ë§ˆ ìš”ì†Œì˜ êµ¬ë¬¸ ë¶„ì„
- ëª…ë ¹í–‰ ì¸ìˆ˜ì—ì„œ ì¸ìˆ˜ ìœ í˜•ì„ ë¶„ì„í•´ ì§„ì§œ ìœ í˜•ìœ¼ë¡œ ë³€í™˜.
- `getXXX`ë©”ì„œë“œë¥¼ êµ¬í˜„í•´ í˜¸ì¶œìì—ê²Œ ì§„ì§œ ìœ í˜•ì„ ë°˜í™˜

<aside>
ğŸ’¡ ì¸ìˆ˜ ìœ í˜•ì€ ë‹¤ì–‘í•˜ì§€ë§Œ ëª¨ë‘ê°€ ìœ ì‚¬í•œ ë©”ì„œë“œë¥¼ ì œê³µí•˜ë¯€ë¡œ í´ë˜ìŠ¤ í•˜ë‚˜ê°€ ì í•©í•˜ë‹¤ íŒë‹¨í–ˆë‹¤. ê·¸ë˜ì„œ `ArgumentMarshaler`ë¼ëŠ” ê°œë…ì´ íƒ„ìƒí–ˆë‹¤.

</aside>

# ì ì§„ì ìœ¼ë¡œ ê°œì„ í•˜ë‹¤.

> í”„ë¡œê·¸ë¨ì„ ë§ì¹˜ëŠ” ê°€ì¥ ì¢‹ì€ ë°©ë²• ì¤‘ í•˜ë‚˜ëŠ” ê°œì„ ì´ë¼ëŠ” ì´ë¦„ ì•„ë˜ êµ¬ì¡°ë¥¼ í¬ê²Œ ë’¤ì§‘ëŠ” í–‰ìœ„ë‹¤.
> 

ê°œì„  ì „ê³¼ ë˜‘ê°™ì€ ê²°ê³¼ë¥¼ ë§Œë“¤ê²Œ í•˜ëŠ” ê²ƒì´ ì–´ë µê¸° ë•Œë¬¸. 

ê·¸ë˜ì„œ í…ŒìŠ¤íŠ¸ ì£¼ë„ ê°œë°œì´ë¼ëŠ” ê¸°ë²•ì„ ì‚¬ìš©í•˜ì—¬, ë³€ê²½ í›„ì—ë„ ì‹œìŠ¤í…œì´ ë³€ê²½ ì „ê³¼ ë˜‘ê°™ì´ ëŒì•„ê°€ëŠ” ê²ƒì„ í™•ì¸í•œë‹¤.

## ArgumentMarshaler

ê° ì¸ìˆ˜ ìœ í˜•ì„ ì²˜ë¦¬í•˜ëŠ” ì½”ë“œë¥¼ Argsë‚´ë¶€ì— ì„ ì–¸ëœ `ArgumentMarshaler` í´ë˜ìŠ¤ì— ì˜®ê¸´ í›„, ì´í›„ `ArgumentMarshaler` íŒŒìƒ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ ë¶„ë¦¬í–ˆë‹¤.

- í”„ë¡œê·¸ë¨ êµ¬ì¡°ë¥¼ ì¡°ê¸ˆì”© ë³€ê²½í•˜ëŠ” ë™ì•ˆì—ë„ ì‹œìŠ¤í…œì˜ ì •ìƒ ë™ì‘ì„ ìœ ì§€í•˜ê¸° ì‰¬ì›Œì§€ê¸° ë•Œë¬¸

ì•„ë˜ ì½”ë“œë¥¼ [Args.java](http://Args.java) ëì— ì¶”ê°€í–ˆë‹¤.

```java
private class ArgumentMarshaler {
    private boolean booleanValue = false;

    public void setBoolean(boolean value) {
        booleanValue = value;
    }

    public boolean getBoolean() {
        return booleanValue;
    }
}

private class BooleanArgumentMarshaler extends ArgumentMarshaler {
}

private class StringArgumentMarshaler extends ArgumentMarshaler {
}

private class IntegerArgumentMarshaler extends ArgumentMarshaler {
}
```

- ì²˜ìŒ `Boolean` ì¸ìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” `HashMap`ì—ì„œ `Boolean` ì¸ìˆ˜ ìœ í˜•ì„ `ArgumentMarshaler`ìœ í˜•ìœ¼ë¡œ ë°”ê¿¨ë‹¤.

```java
private Map<Character, **ArgumentMarshaler**> booleanArgs = new HashMap<Character, **ArgumentMarshaler**>();
```

- ê·¸ í›„ ê¹¨ì§„ ë¶€ë¶„ì— ë³€ê²½ì„ ë°˜ì˜í–ˆë‹¤.

```java
private void parseBooleanSchemaElement(char elementId) {
    booleanArgs.put(elementId, **new BooleanArgumentMarshaler()**);
}
...
private void setBooleanArg(char argChar, boolean value) {
    booleanArgs.**get**(argChar).**setBoolean**(value);
}
...
public boolean getBoolean(char arg) {
    return falseIfNull(booleanArgs.get(arg).**getBoolean**());
}
```

ìƒˆ ì¸ìˆ˜ ìœ í˜•ì„ ì¶”ê°€í•˜ë ¤ë©´ ì„¸ ê³³ (parse, get, set)ì„ ë³€ê²½í•´ì•¼ í–ˆëŠ”ë°, ì •í™•íˆ í•´ë‹¹ ì˜ì—­ì—ì„œ ë³€ê²½ì´ ì´ë£¨ì–´ì¡Œë‹¤.

`booleanArgs`ê°€ `ArgumentMarshaler` ë¥¼ ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ê²Œ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ ìœ„ `getBoolean`ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê¸°ì¡´ `falseIfNull`ì´ `NullPointerException`ì„ ë§‰ì„ ìˆ˜ ì—†ì—ˆë‹¤.

```java
...
private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>();

...

private class ArgumentMarshaler {
    ...
    public boolean getBoolean(char arg) {
        Args.ArgumentMarshaler am = booleanArgs.get(arg);
        return am != null && am.getBoolean();
    }
}
```

`ArgumentMarshaler.getBoolean` ì—ì„œ nullì„ ê²€ì‚¬í•˜ê²Œ êµ¬í˜„í•˜ê³  ê¸°ì¡´ falseIfNullì„ ì œê±°í–ˆë‹¤. 

# String ì¸ìˆ˜ ì¶”ê°€

Boolean ì¸ìˆ˜ë¥¼ ì¶”ê°€í•˜ëŠ” ê³¼ì •ê³¼ ìœ ì‚¬í•˜ê²Œ String ì¸ìˆ˜ë¥¼ ì¶”ê°€í–ˆë‹¤.

```java
private Map<Character, **ArgumentMarshaler**> stringArgs = new HashMap<Character, **ArgumentMarshaler**>();

private void parseStringSchemaElement(char elementId) {
    stringArgs.put(elementId, **new StringArgumentMarshaler()**);
}

// ...

private void setStringArg(char argChar) throws ArgsException {
    currentArgument++;
    try {
        stringArgs.**get**(argChar).**setString**(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
        valid = false;
        errorArgumentId = argChar;
        errorCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}

// ...

public String getString(char arg) {
    **Args.ArgumentMarshaler am** = stringArgs.get(arg);
    return am == null ? "" : am.getString();
}

// ...

private class ArgumentMarshaler {
    private String stringValue;

    public void setString(String s) {
        stringValue = s;
    }

    public String getString() {
        return stringValue == null ? "" : stringValue;
    }
}
```

í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ê°€ í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ë‹¤ìŒ ë³€ê²½ìœ¼ë¡œ ë„˜ì–´ê°€ê¸° ì „ì— ì˜¤ë¥˜ë¥¼ ìˆ˜ì •í–ˆë‹¤.

ë§ˆì°¬ê°€ì§€ë¡œ int ì¸ìˆ˜ ê¸°ëŠ¥ë„ ì¶”ê°€í–ˆë‹¤.

## ì¶”ìƒí´ë˜ìŠ¤ë¥¼ ì´ìš©í•œ ë¶„ë¦¬

`Boolean`, `String`, `Integer` ì¸ìˆ˜ ì²˜ë¦¬ì— ëŒ€í•œ ëª¨ë“  ê¸°ëŠ¥ì„ `Args`ì˜ `ArgumentMarshaler`ë¡œ ì˜®ê²¼ìœ¼ë¯€ë¡œ ë¯¸ë¦¬ ì„ ì–¸í•´ë‘” íŒŒìƒ í´ë˜ìŠ¤ë¡œ ë¶„ì‚°í•œë‹¤.

```java
private **abstract** class ArgumentMarshaler {
    **protected** boolean booleanValue = false;
    private String stringValue;
    private int integerValue;

    public void setBoolean(boolean value) {
        booleanValue = value;
    }

    public boolean getBoolean() {
        return booleanValue;
    }

    public void setString(String s) {
        stringValue = s;
    }

    public String getString() {
        return stringValue == null ? "" : stringValue;
    }

    public void setInteger(int i) {
        integerValue = i;
    }

    public int getInteger() {
        return integerValue;
    }

    **public abstract void set(String s);**
}
```

ì ì§„ì ìœ¼ë¡œ í•œë‹¨ê³„ì”© ê°œì„ í•˜ê¸° ìœ„í•´ `ArgumentMarshaler`ë¥¼ ì¶”ìƒ í´ë˜ìŠ¤ë¡œ ë°”ê¾¸ê³  í•˜ë‚˜ì”© ì˜®ê¸´ë‹¤.

```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    public void set(String s) {
        booleanValue = true;
    }
}
```

`ArgumentMarshaler`ë¥¼ ìƒì†ë°›ì€ ìœ í˜• ë³„ í´ë˜ìŠ¤ì— `set`ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ê³ , ê¸°ì¡´ `ArgumentMarshaler.setXXX`ì„ `set`ìœ¼ë¡œ ëŒ€ì²´í•œë‹¤.

â†’ `BooleanArgumentMarshaler.set` ì—ì„œ së¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠìŒì—ë„ ì„ ì–¸í•œ ì´ìœ ëŠ” `ArgumentMarshaler` ë¥¼ ìƒì†ë°›ëŠ” ë‹¤ë¥¸ í´ë˜ìŠ¤ë“¤ì´ String ì¸ìë¥¼ ë°›ì•„ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸

## get

```java
private abstract class ArgumentMarshaler {
    protected boolean booleanValue = false;
    ...
    **public abstract void get();**
}
```

getì„ ì¶”ìƒ ë©”ì„œë“œë¡œ ë§Œë“  í›„ ë¡œì§ì„ ì¶”ê°€í•œë‹¤.

```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    **private boolean booleanValue = false;**
    public void set(String s) {
        booleanValue = true;
    }

    **public Object get() {
        return booleanValue;
    }**
}
```

ê·¸ í›„ `ArgumentMarshaler` ì— `protected`ë¡œ ì„ ì–¸ë˜ì–´ìˆë˜ ë³€ìˆ˜ë¥¼ `xxxArgumentMarshaler`ì˜ `private`ë³€ìˆ˜ë¡œ ì„ ì–¸í•œë‹¤. 

## ArgumentMarshaler ê²€ì¦

```java
private abstract class ArgumentMarshaler {
    ...
    **public abstract Object get();
    public abstract void set(String s) throws ArgsException;**
}
```

`set`ì„ í†µí•´ `ArgumentMarshaler`ë¥¼ ìƒì†ë°›ì€ í´ë˜ìŠ¤ì˜ `private`ë³€ìˆ˜ì¸ `xxxValue`ì— ê°’ì„ í• ë‹¹í•˜ê²Œ ë˜ëŠ”ë° ìë£Œí˜•ì´ ë‹¤ë¥¼ê²½ìš° ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.

# HashMap í†µí•©

`xxxArgs`ë¥¼ í†µí•©í•˜ê¸° ìœ„í•œ ì²«ê±¸ìŒìœ¼ë¡œ `marshalers` ë¥¼ ì¶”ê°€í–ˆë‹¤.

```java
public class Args {
    // ...
    private Map<Character, ArgumentMarshaler> booleanArgs = new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> stringArgs = new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> intArgs = new HashMap<Character, ArgumentMarshaler>();
    **private Map<Character, ArgumentMarshaler> marshalers = new HashMap<Character, ArgumentMarshaler>();**
    // ...

    private void parseBooleanSchemaElement(char elementId) {
        ArgumentMarshaler m = new BooleanArgumentMarshaler();
        booleanArgs.put(elementId, m);
        **marshalers.put(elementId, m);**
    }

    private void parseIntegerSchemaElement(char elementId) {
        ArgumentMarshaler m = new IntegerArgumentMarshaler();
        intArgs.put(elementId, m);
        **marshalers.put(elementId, m);**
    }

    private void parseStringSchemaElement(char elementId) {
        ArgumentMarshaler m = new StringArgumentMarshaler();
        stringArgs.put(elementId, m);
        **marshalers.put(elementId, m);**
    }
}
```

ê·¸ í›„ `parseXXX` ë©”ì„œë“œì—  `marshalers.put`ì„ ìˆ˜í–‰í•˜ì—¬ í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•˜ì§€ ì•ŠëŠ”ì§€ ì‚´íˆë‹¤. í…ŒìŠ¤íŠ¸ëŠ” ì‹¤íŒ¨ì—†ì´ ëŒì•„ê°”ë‹¤.

```java
private boolean isBooleanArg(char argChar) {
    return booleanArgs.containsKey(argChar);
}
```

ê·¸ í›„ `Args.isBooleanArgs`ë¥¼ ì•„ë˜ë¡œ ìˆ˜ì •í–ˆë‹¤. 

```java
private boolean isBooleanArg(char argChar) {
    ArgumentMarshaler m = marshalers.get(argChar);
    return m instanceof BooleanArgumentMarshaler;
}
```

ìˆ˜ì • í›„ í…ŒìŠ¤íŠ¸ë¥¼ ëª¨ë‘ í†µê³¼í•˜ì—¬ ë‹¤ë¥¸ í•­ëª©ë“¤ì— ëŒ€í•´ì„œë„ ë™ì¼í•œ ìˆ˜ì •ì„ í–ˆë‹¤. ë³€ê²½í›„ì—ë„ í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•˜ì—¬ `marshalers.get`ì„ í˜¸ì¶œí•˜ëŠ” ì½”ë“œë¥¼ í†µí•©í–ˆë‹¤.

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (isBooleanArg(m))
        setBooleanArg(argChar);
    else if (isStringArg(m))
        setStringArg(argChar);
    else if (isIntArg(m))
        setIntArg(argChar);
    else
        return false;
    return true;
}

private boolean isIntArg(ArgumentMarshaler m) {
    return m instanceof IntegerArgumentMarshaler;
}

private boolean isStringArg(ArgumentMarshaler m) {
    return m instanceof StringArgumentMarshaler;
}

private boolean isBooleanArg(ArgumentMarshaler m) {
    return m instanceof BooleanArgumentMarshaler;
}
```

ë‹¤ìŒìœ¼ë¡œ `set`í•¨ìˆ˜ì—ì„œ ê¸°ì¡´ `HashMap`ì„ `marshalers HashMap`ìœ¼ë¡œ êµì²´í•œë‹¤.

```java
private void setBooleanArg(ArgumentMarshaler m) {
    try {
        m.set("true"); // was: booleanArgs.get(argChar).set("true");
    } catch (ArgsException e) {
    }
}
```

ê° setXXXì˜ í˜•ì‹ì„ í†µí•©í•˜ì—¬ ì˜ˆì™¸ì²˜ë¦¬ë¥¼ ë™ì¼í•˜ê²Œ ì ìš©í•  ìˆ˜ ìˆì—ˆë‹¤.

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    try {
        if (m instanceof BooleanArgumentMarshaler)
            setBooleanArg(m);
        else if (m instanceof StringArgumentMarshaler)
            setStringArg(m);
        else if (m instanceof IntegerArgumentMarshaler)
            setIntArg(m);
        else
            return false;
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}

private void setIntArg(ArgumentMarshaler m) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
        parameter = args[currentArgument];
        m.set(parameter);
    } catch (ArrayIndexOutOfBoundsException e) {
        errorCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
    } catch (ArgsException e) {
        errorParameter = parameter;
        errorCode = ErrorCode.INVALID_INTEGER;
        throw e;
    }
}

private void setStringArg(ArgumentMarshaler m) throws ArgsException {
    currentArgument++;
    try {
        m.set(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
        errorCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
```

## HashMap í†µí•©

`ArgumentMarshaler`ë¥¼ ì´ìš©í•˜ì—¬ ë§Œë“  ìœ í˜•ë³„ `HashMap`ì„ í•˜ë‚˜ì˜ `HashMap`ìœ¼ë¡œ í†µí•©í•œë‹¤. 

```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    boolean b = false;
    try {
        b = am != null && (Boolean) am.get();
    } catch (ClassCastException e) {
        b = false;
    }
    return b;
}
```

ì´ì—ë”°ë¼ ë‹¤ë¥¸ ì¸ìˆ˜ìœ í˜•ë„ ì•„ë˜ì™€ ê°™ì´ ë³€ê²½ ê°€ëŠ¥í–ˆê³ ,

```java
private void parseBooleanSchemaElement(char elementId) {
    ArgumentMarshaler m = new BooleanArgumentMarshaler();
    ~~booleanArgs.put(elementId, m);~~
    marshalers.put(elementId, m);
}
```

ê²°ê³¼ì ìœ¼ë¡œ í•˜ë‚˜ì˜ Hashmapìœ¼ë¡œ í†µí•© ê°€ëŠ¥í–ˆë‹¤.

## setArgument

ìœ í˜•ì„ ì¼ì¼ì´ í™•ì¸í•˜ëŠ” ì½”ë“œë¥¼ ì—†ì• ê³  `ArgumentMarshaler.set`ë§Œìœ¼ë¡œ ë§Œë“ ë‹¤.

setXXXArgë¥¼ ê°ê° `ArgumentMarshaler` ë¡œ ë‚´ë ¤ì•¼ í•˜ëŠ”ë°, setIntArgsëŠ” argsì™€ currentArgumentë¼ëŠ” ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ë‘ê°œê°€ ì“°ì¸ë‹¤.

í•´ë‹¹ ë©”ì„œë“œë¥¼ ë‚´ë¦¬ë ¤ë©´ argsì™€ currentArgumentë¥¼ ì¸ìˆ˜ë¡œ ë„˜ê²¨ì•¼ í•˜ë¯€ë¡œ(ì¸ìˆ˜ê°€ ë§ì•„ì§€ë¯€ë¡œ) ì½”ë“œê°€ ì§€ì €ë¶„í•´ì§„ë‹¤.

ë”°ë¼ì„œ `args`ë¥¼ `list`ë¡œ ë³€í™˜ í›„ `Iterator`ë¥¼ `set` í•¨ìˆ˜ë¡œ ì „ë‹¬í•œë‹¤.

```java
public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, ArgumentMarshaler> marshalers = new HashMap<Character, ArgumentMarshaler>();
    private Set<Character> argsFound = new HashSet<Character>();
    **private Iterator<String> currentArgument;**
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;
    **private List<String> argsList;**

    private enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT
    }

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        **argsList = Arrays.asList(args);**
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && **argsList.size()** == 0)
            return true;
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }

    // ---
    private boolean parseArguments() throws ArgsException {
        for (currentArgument = **argsList.iterator()**; currentArgument.**hasNext()**;) {
            String arg = currentArgument.**next()**;
            parseArgument(arg);
        }
        return true;
    }

    // ---
    private void setIntArg(ArgumentMarshaler m) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.**next()**;
            m.set(parameter);
        } catch (**NoSuchElementException** e) {
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (ArgsException e) {
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw e;
        }
    }

    private void setStringArg(ArgumentMarshaler m) throws ArgsException {
        try {
            m.set(currentArgument.**next()**);
        } catch (**NoSuchElementException** e) {
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }
}
```

ë”°ë¼ì„œ `args`ë¥¼ `list`ë¡œ ë³€í™˜ í›„ `Iterator`ë¥¼ `set` í•¨ìˆ˜ë¡œ ì „ë‹¬í•˜ëŠ” ë³€ê²½ í›„ì— í…ŒìŠ¤íŠ¸ë¥¼ ëª¨ë‘ í†µê³¼í–ˆë‹¤. `set` í•¨ìˆ˜ë¥¼ ì ì ˆí•œ íŒŒìƒ í´ë˜ìŠ¤ë¡œ ë‚´ë ¤ë„ ê´œì°®ì•„ì ¸ ì²˜ìŒìœ¼ë¡œ `setArgument`ë¥¼ ì•„ë˜ë¡œ ë³€ê²½í–ˆë‹¤.

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
        return false;
    try {
        if (m instanceof BooleanArgumentMarshaler)
            setBooleanArg(m);
        else if (m instanceof StringArgumentMarshaler)
            setStringArg(m);
        else if (m instanceof IntegerArgumentMarshaler)
            setIntArg(m);
        ~~else
            return false;~~
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}
```

ì—°ì‡„ì ì¸ if-else êµ¬ë¬¸ì„ ì™„ì „íˆ ì œê±°í•˜ê¸° ìœ„í•´ ì œê±°í•˜ê³  ì˜¤ë¥˜ ì½”ë“œë¥¼ ë”°ë¡œ êº¼ëƒˆë‹¤.

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
        return false;
    try {
        if (m instanceof BooleanArgumentMarshaler)
            setBooleanArg(m, currentArgument);
        else if (m instanceof StringArgumentMarshaler)
            setStringArg(m);
        else if (m instanceof IntegerArgumentMarshaler)
            setIntArg(m);
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}
// ---

private void setBooleanArg(ArgumentMarshaler m, Iterator<String> currentArgument) throws ArgsException {
    ~~try {~~
        m.set("true");
    ~~catch (ArgsException e) {
    }~~
}
```

ë‹¨ê³„ì ìœ¼ë¡œ ì¡°ê¸ˆì”© ë³€ê²½í•˜ë©° ë§¤ë²ˆ í…ŒìŠ¤íŠ¸ë¥¼ ëŒë ¤ì•¼ í•˜ë¯€ë¡œ ì½”ë“œë¥¼ ì˜®ê¸°ê³  ì œê±°í•˜ëŠ” ì¼ì´ ë§ì•„ì§„ë‹¤.

ìœ„ì™€ ë§ˆì°¬ê°€ì§€ë¡œ iteratorë¥¼ ì¸ìë¡œ ë°›ëŠ” ì´ìœ ëŠ” ì¶”ìƒ ë©”ì„œë“œë¡œ í˜¸ì¶œí•˜ê¸° ìœ„í•´ì„œë‹¤.

```java
private abstract class ArgumentMarshaler {
    public abstract void set(Iterator<String> currentArgument)
            throws ArgsException;

    public abstract void set(String s) throws ArgsException;

    public abstract Object get();
}

private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    private boolean booleanValue = false;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        booleanValue = true;
    }

    public void set(String s) {
        booleanValue = true;
    }

    public Object get() {
        return booleanValue;
    }
}

private class StringArgumentMarshaler extends ArgumentMarshaler {
    private String stringValue = "";

    public void set(Iterator<String> currentArgument) throws ArgsException {
    }

    public void set(String s) {
        stringValue = s;
    }

    public Object get() {
        return stringValue;
    }
}

private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0;

    public void set(Iterator<String> currentArgument) throws ArgsException {
    }

    public void set(String s) throws ArgsException {
        try {
            intValue = Integer.parseInt(s);
        } catch (NumberFormatException e) {
            throw new ArgsException();
        }
    }

    public Object get() {
        return intValue;
    }
}
```

ìƒˆë¡œìš´ ì¶”ìƒ ë©”ì„œë“œë¥¼ ì¶”ê°€í•˜ê³  ê°ê° ë³€ê²½í•œë‹¤.

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
        return false;
    try {
        if (m instanceof BooleanArgumentMarshaler)
            m.set(currentArgument);
        else if (m instanceof StringArgumentMarshaler)
            m.set(currentArgument);
        else if (m instanceof IntegerArgumentMarshaler)
            m.set(currentArgument);
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}

private class StringArgumentMarshaler extends ArgumentMarshaler {
    private String stringValue = "";

    public void set(Iterator<String> currentArgument) throws ArgsException {
        try {
            stringValue = currentArgument.next();
        } catch (NoSuchElementException e) {
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }

    public void set(String s) {
    }

    public Object get() {
        return stringValue;
    }
}

private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            set(parameter);
        } catch (NoSuchElementException e) {
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (ArgsException e) {
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw e;
        }
    }

    public void set(String s) throws ArgsException {
        try {
            intValue = Integer.parseInt(s);
        } catch (NumberFormatException e) {
            throw new ArgsException();
        }
    }

    public Object get() {
        return intValue;
    }
}
```

`setArgument`ê°€ í…ŒìŠ¤íŠ¸ì— í†µê³¼í•˜ë©´ `m.set`ì´ ì •ìƒ ë™ì‘ì„ ì˜ë¯¸í•˜ë¯€ë¡œ í†µí•©í•  ìˆ˜ ìˆë‹¤.

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
        return false;
    try {
        m.set(currentArgument);
        return true;
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
}
```

ë§ˆì§€ë§‰ìœ¼ë¡œ `ArgumentMarshaler`ë¥¼ ì¸í„°í˜ì´ìŠ¤ë¡œ ë³€ê²½í•˜ë©´ ì™„ë£Œëœë‹¤.

```java
private interface ArgumentMarshaler {
    void set(Iterator<String> currentArgument) throws ArgsException;
    Object get();
}
```

# ê²°ë¡ 

```java
package com.objectmentor.utilities.args;

import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;
import java.util.*;

public class Args {
    private Map<Character, ArgumentMarshaler> marshalers;
    private Set<Character> argsFound;
    private ListIterator<String> currentArgument;

    public Args(String schema, String[] args) throws ArgsException {
        marshalers = new HashMap<Character, ArgumentMarshaler>();
        argsFound = new HashSet<Character>();
        parseSchema(schema);
        parseArgumentStrings(Arrays.asList(args));
    }

    private void parseSchema(String schema) throws ArgsException {
        for (String element : schema.split(","))
            if (element.length() > 0)
                parseSchemaElement(element.trim());
    }

    private void parseSchemaElement(String element) throws ArgsException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (elementTail.length() == 0)
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        else if (elementTail.equals("*"))
            marshalers.put(elementId, new StringArgumentMarshaler());
        else if (elementTail.equals("#"))
            marshalers.put(elementId, new IntegerArgumentMarshaler());
        else if (elementTail.equals("##"))
            marshalers.put(elementId, new DoubleArgumentMarshaler());
        else if (elementTail.equals("[*]"))
            marshalers.put(elementId, new StringArrayArgumentMarshaler());
        else
            throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail);
    }

    private void validateSchemaElementId(char elementId) throws ArgsException {
        if (!Character.isLetter(elementId))
            throw new ArgsException(INVALID_ARGUMENT_NAME, elementId, null);
    }

    private void parseArgumentStrings(List<String> argsList) throws ArgsException {
        for (currentArgument = argsList.listIterator(); currentArgument.hasNext();) {
            String argString = currentArgument.next();
            if (argString.startsWith("-")) {
                parseArgumentCharacters(argString.substring(1));
            } else {
                currentArgument.previous();
                break;
            }
        }
    }

    private void parseArgumentCharacters(String argChars) throws ArgsException {
        for (int i = 0; i < argChars.length(); i++)
            parseArgumentCharacter(argChars.charAt(i));
    }

    private void parseArgumentCharacter(char argChar) throws ArgsException {
        ArgumentMarshaler m = marshalers.get(argChar);
        if (m == null) {
            throw new ArgsException(UNEXPECTED_ARGUMENT, argChar, null);
        } else {
            argsFound.add(argChar);
            try {
                m.set(currentArgument);
            } catch (ArgsException e) {
                e.setErrorArgumentId(argChar);
                throw e;
            }
        }
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public int nextArgument() {
        return currentArgument.nextIndex();
    }

    public boolean getBoolean(char arg) {
        return BooleanArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public String getString(char arg) {
        return StringArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public int getInt(char arg) {
        return IntegerArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public double getDouble(char arg) {
        return DoubleArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public String[] getStringArray(char arg) {
        return StringArrayArgumentMarshaler.getValue(marshalers.get(arg));
    }
}
```

```java
public interface ArgumentMarshaler {
    void set(Iterator<String> currentArgument) throws ArgsException;
}
```

```java
public class BooleanArgumentMarshaler implements ArgumentMarshaler {
    private boolean booleanValue = false;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        booleanValue = true;
    }

    public static boolean getValue(ArgumentMarshaler am) {
        if (am != null && am instanceof BooleanArgumentMarshaler)
            return ((BooleanArgumentMarshaler) am).booleanValue;
        else
            return false;
    }
}
```

```java
import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;

public class StringArgumentMarshaler implements ArgumentMarshaler {
    private String stringValue = "";

    public void set(Iterator<String> currentArgument) throws ArgsException {
        try {
            stringValue = currentArgument.next();
        } catch (NoSuchElementException e) {
            throw new ArgsException(MISSING_STRING);
        }
    }

    public static String getValue(ArgumentMarshaler am) {
        if (am != null && am instanceof StringArgumentMarshaler)
            return ((StringArgumentMarshaler) am).stringValue;
        else
            return "";
    }
}
```

```java
import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;

public class IntegerArgumentMarshaler implements ArgumentMarshaler {
    private int intValue = 0;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            intValue = Integer.parseInt(parameter);
        } catch (NoSuchElementException e) {
            throw new ArgsException(MISSING_INTEGER);
        } catch (NumberFormatException e) {
            throw new ArgsException(INVALID_INTEGER, parameter);
        }
    }

    public static int getValue(ArgumentMarshaler am) {
        if (am != null && am instanceof IntegerArgumentMarshaler)
            return ((IntegerArgumentMarshaler) am).intValue;
        else
            return 0;
    }
}
```

ë¦¬í™í† ë§ì„ ì•ˆì „í•˜ê²Œ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ ì¡°ê¸ˆì”© ë³€ê²½í•˜ëŠ” ê³¼ì •ì„ ê±°ì³¤ë‹¤. ê²°ê³¼ì ìœ¼ë¡œ ì ˆì°¨ì ì¸ ì½”ë“œê°€  ê°ì²´ì§€í–¥ì ìœ¼ë¡œ ë¦¬í™í† ë§ ë˜ì—ˆë‹¤.

- ê·œëª¨ê°€ ìˆëŠ” ì½”ë“œë¥¼ í•œë²ˆì— ë³€ê²½í•˜ëŠ” ê²ƒì€ ë§¤ìš° ì–´ë µë‹¤.
- ë”°ë¼ì„œ í…ŒìŠ¤íŠ¸ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¡°ê¸ˆì”© ë³€ê²½í•˜ëŠ” ê³¼ì •ì„ ê±°ì³¤ë‹¤.

í…ŒìŠ¤íŠ¸ëŠ” ë§¤ìš° ì¤‘ìš”í•˜ë‹¤!
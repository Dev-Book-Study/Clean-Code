# Clean Code : 추천사 및 1장(깨끗한 코드), 2장(의미 있는 이름)

다니는 회사의 인턴 부터 시작해 정규직이 되고 난 후, 신규 프로젝트에 투입되었는데, **다른 사람의 코드를 분석하고 활용해야 하는 경우**가 많았습니다. 예전부터 확장성 있고 효율적인 좋은 코드에 대해 관심이 있었지만, 이번 신규 프로젝트를 통해 좋은 코드의 중요성에 대해 한 번 더 느끼게 되어 공채 동기들과 함께  `Clean Code - 로버트 C. 마틴`을 베이스로 하는 Clean Code 스터디를 시작하게 되었습니다.





## 추천사

`James O. Coplien`의 추천사는 덴마크의 속담인 `사소한 곳에서 발휘하는 정직은 사소하지 않다`라는 문구로 시작합니다. 이 속담이 저에게는 **사소한 것에 신경쓰고 관심가지는 것이 모여 큰 것을 이룬다는 의미**로 다가왔는데, 평소에 좋아한 미켈란젤로의 `I know. I"ve been there.(내가 안다.)`라는 말이 나오는 일화와 비슷한 느낌의 속담이라 반가웠습니다 :)

추천사에서 5S 원칙을 소개하였는데, 이 5S 원칙은 소프트워에 개발자라면 선택이 아니라 필수라고 소개했습니다. 5S 원칙은 아래와 같습니다. (덴마크어로 되어있는 것 같습니다.)

1. `Seiri(정리 or 조직 or 정렬)` : 적절한 명명법 등과 같은 방법을 사용해 무엇이 어디에 있는지 알아야 합니다.
2. `Seiton(정돈 or 단정함 or 체계화)` : 코드는 누구나 예상하는 위치에 있어야 합니다.
3. `Seiso(청소 or 정리 or 광내기)` : 과거 이력이나 미래에 대한 바람을 기재한 주석 혹은 주석으로 처리한 코드는 제거해야 합니다.
4. `Seiketsu(청결 or 표준화)` : 그룹 내에서 일관적은 구현 스타일과 기법이 필요합니다.
5. `Shutsuke(생활화 or 규율)` : 관례를 따르고 자기 코드를 자주 돌아보고 변경해야 합니다.

5번은 **진정으로 책임 있는 개발자라면 제품 생명주기까지 고려**해야 한다는 의미라고 합니다.





## 1장. 깨끗한 코드

`왜 좋은 코드가 중요할까요??` 좋은 코드의 장점을 나열하기 보다는 좋은 코드를 신경쓰지 않아 망한 회사를 예를 들어보겠습니다.

80년대 후반 `킬러 앱 하나를 구현한 회사`가 있었습니다. 제품은 커다란 인기를 끌었는데, 제품 출시 주기가 점점 늦어지더니 버그와 프로그램이 죽는 횟수가 늘어나더니 결국 **회사가 망했습니다. 원인은 예상하다시피 출시에 바빠 구현에만 신경쓴 코드를 작성**하였다는 것입니다. 때문에 기능을 추가할수록 코드는 엉망이 되어갔고 결국은 감당이 불가능한 수준에 이르렀습니다. 즉, **회사가 망한 원인이 나쁜 코드 탓**이었던 것입니다.

여기서 생각해볼 것은 `왜 나쁜 코드를 작성하는 것일까요??`라는 물음입니다. 대부분은 급해서, 서두르느라, 나중에 고치려고 나쁜 코드를 작성하게 됩니다. 하지만 `르블랑의 법칙(Leblanc's Law)`에 따르면 나중은 결코 오지 않습니다. 위의 경우처럼 나쁜 코드는 극단적으로는 회사가 망할수도 있고, 개발 속도를 크게 떨어뜨리기 때문에 **처음 부터 좋은 코드를 작성하는 것이 중요**합니다.

> **르블랑의 법칙(Leblanc's Law)** : 나중은 결코 오지 않는다는 의미입니다. 나중에 손보겠다고 한 코드를 작성하면 돌아간다는 사실에 안도감을 느끼며 위로하게 되고 결국 고치지 않게 되는 것입니다.

하지만 나중에 리팩토링하면 되지 않을까 생각할 수 있습니다. 하지만 회사는 계속적으로 이윤을 창출해야 합니다. 때문에 **새로운 서비스나 기능을 추가하면서 리팩토링 팀을 만들게 됩니다.** 이 때부터는 **리팩토링 팀과 기존 팀과의 경주가 시작되는 것**입니다. 때때로 이 경주는 아주 오랫동안 이어지고 초기 레이스의 코드가 몇 년뒤의 경주에서는 나쁜 코드가 되어있을 가능성이 있습니다. 때문에 **초기부터 깨끗한 코드를 만드려는 노력이 비용을 절감하고 전문가로서 살아남는 방법**인 것입니다.



### 1-1. 태도

**나쁜 코드가 생기는 이유는 가지각각 이지만 전적으로 프로그래머 잘못**이라고 합니다. 

예를 들어, 어느 환자가 수술 전에 손을 씻지 말라고 요구한다고 해도 의사는 단호하게 거부할 것입니다. 그 이유는 질병과 감염의 위험은 환자보다 의사가 더 잘 알고 그 행동은 전문가답지 못하기 때문입니다.

프로그래머도 마찬가지입니다. **나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못한 것**입니다.

#### 나의 생각

저도 전적으로 프로그래머 잘못이라고 생각은 하지만,,, 정말 어쩔 수 없는 상황도 있다고 생각합니다. 때문에 이런 경우에는 **프로그래머가 전적으로 책임지고 르블랑의 법칙을 깨뜨리려고 노력해야 한다고 생각**합니다.



### 1-2. 원초적 난제

**한두 해 이상 몸 담은 프로그래머라면 나쁜 코드가 업무 속도를 늦춘다는 사실을 알고 있습니다.** 하지만 기한을 맞추려면 나쁜 코드를 양산할 수 밖에 없다고 느낍니다. 하지만 오히려 나쁜 코드를 양산하는 것이 기한을 맞추지 못하게 될 수도 있습니다. 그러니까 **기한을 맞추려면 코드를 최대한 깨끗하게 유지하는 습관이 필요**합니다.



### 1-3. 깨진 유리창 이론과 보이스카웃 규칙

깨끗한 코드를 설명할 때 많이 나오는 이론을 소개하겠습니다.

- `깨진 유리창 이론` : 깨진 유리창 하나를 방치해 두면, 그 지점을 중심으로 범죄가 확산되기 시작한다는 이론으로, 사소한 무질서를 방치하면 큰 문제로 이어질 가능성이 높다는 의미를 담고 있습니다.
  - **나쁜 코드를 방치하면 그 나쁜 코드를 중심으로 나쁜 코드가 확산된다는 의미로 많이 사용** 됩니다.

- `보이스카웃 규칙` : 엉망으로 어질러져 있는 곳을 발견하면, 일단 청소하고 누가 그렇게 했는지는 생각하지 말고 다음으로 야영하러 오는 사람들을 위해 신경써서 환경을 개선하라는 규칙으로 언제나 처음 왔을 때보다 깨끗하게 해놓고 캠프장을 떠날 것이라는 의미를 담고 있습니다.
  - **나쁜 코드를 발견하면 원래 코드를 작성한 사람이 누구이건 간에, 좋은 코드로 개선하려는 노력이 필요하다는 의미로 많이 사용** 됩니다.



### 1-4. 깨끗한 코드란?

깨끗한 코드를 작성하려면 `코드 감각`이 필요합니다. 때문에 **코드 감각을 키우기 위한 노력**을 해야합니다. 아래는 유명하고 노련한 프로그래머들이 생각하는 깨끗한 코드에 대한 글입니다.

#### Bjarne Stroustrup(비야네 스트롭스트룹)

`C++ 창시자` 이자 `The C++ Progrmming Language` 저자 입니다. **효율적이고 꼼꼼한 처리를 강조**하는 것을 볼 수 있습니다.

> 나는 우아하고 효율적인 코드를 좋아한다.
> 논리가 간단해야 버그가 숨어들지 못한다.
> 의존성을 최대한 줄여야 유지보수가 쉬워진다.
> 오류는 명백한 전략에 의거해 철저히 처리한다.
> 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다.
> 깨끗한 코드는 한 가지를 제대로 한다.

#### Grady Booth(그래디 부치)

`Object Oriented Analysis and Design with Application` 저자 입니다. **가독성을 강조**하는 것을 볼 수 있습니다.

> 깨끗한 코드는 단순하고 직접적이다.
> 깨끗한 코드는 잘 쓴 문장처럼 읽힌다.
> 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다.

#### Big Dave Thomas(큰 형님 데이브 토마스)

큰 형님 이라는 것 보니 동생도 있는 것 같습니다.  `OTI` 창립자이자 이클립스 전략의 대부입니다. **가독성을 강조하고 깨끗한 코드는 다른 사람이 고치기 쉽다고 단언**하는 것을 볼 수 있습니다.

> 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.
> 단위 테스트 케이스와 인수 테스트 케이스가 존재한다.
> 깨끗한 코드에는 의미 있는 이름이 붙는다.
> 특정 목적을 달성하는 방법은 여러 가지가 아니라 하나만 제공한다.
> 의존성은 최소이며 각 의존성을 명확히 정의한다.
> API는 명확하며 최소로 줄였다.
> 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.

#### Michael Feathers(마이클 페더스)

`Working Effectively with Legacy Code`저자 입니다. **코드를 주의 깊게 짜는 것이 중요하다고 강조**하는 것을 볼 수 있습니다.

> 깨끗한 코드의 특징은 많지만 그 중에서도 모두를 아우르는 특징이 하나 있다. 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다.(작성자가 이미 모든 사항을 고려했으므로) 고칠 궁리를 하다보면 언제나 제자리로 돌아온다. 그리고는 누군가 남겨준 코드, 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다.

#### Ron Jeffries(론 제프리스)

`Extreme Programming Installed`와 `Extreme Programming Adventure in C#`저자 입니다. 론은 스트레티직 에어 커맨드 사에서 포트란으로 프로그래밍을 시작한 이래 거의 모든 플랫폼에서 거의 모든 언어로 코드를 구현해왔다고 합니다. **중복과 표현력 높이기, 초반부터 간단한 추상화 고려하기 이 3가지만 신경 써도 깨끗한 코드라는 목표에 성큼 다가갈 수 있다고 강조**합니다.

> 최근 들어 나는 켄트 벡이 제안한 단순한 코드 규칙으로 구현을 시작하고 끝낸다. 중요한 순으로 나열하자면 간단한 코드는 아래의 규칙을 만족합니다.
>
> - 모든 테스트를 통과한다.
> - 중복이 없다.
> - 시스템 내 모든 설계 아이디어를 표현한다.
> - 클래스, 메서드, 함수 등을 최대한 줄인다.
>
> 규칙을 설명한 후 여러 내용이 있지만
>
> - **중복을 피하라.**
> - **한 기능만 수행하라.**
> - **제대로 표현하라.**
> - **작게 추상화하라.**
>
> 이 몇개의 문단으로 요약할 수 있습니다.

#### Ward Cunningham(워드 커닝햄)

`Wiki(위키)` 창시자, `Fit(피트)` 창시자, `Extreme Programming(익스트림 프로그래밍)` 공동 창시자, 디자인 패턴을 뒤에서 움직이는 전문가, 스몰토크와 객체 지향의 정신적 지도자, 코드를 사랑하는 프로그래머들의 대부 입니다. **명백하고 단순해 짐작한대로 돌아가는 코드가 깨끗한 코드라고 강조**하는 것을 알 수 있습니다.

> 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드로 불러도 되겠다.
> 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.



### 1-5. 1장을 마치며...

**예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없으니, 이 책을 읽는다고 뛰어난 프로그래머가 된다는 보장은 없다**고 이 책은 말합니다. 단지 뛰어난 프로그래머가 생각하는 방식과 그들이 사용하는 기술과 기교와 도구를 소개하는 것이기 때문에 이 책을 읽고 `실무에서의 적용`이나 `코드 감각`을 키우는 것은 이 책을 읽는 우리들에게 달렸습니다.

이 책은 `객체 지향 설계 원칙 SOLID`를 산발적으로 거론하기 때문에 SOLID를 알고가야 할 필요성이 있습니다.

**참고 링크**

- [객체 지향 설계 원칙(SOLID) 이란?](https://dev-splin.github.io/cs(computer%20science)/CS-Development-common-sense/#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%A0%81-%EC%84%A4%EA%B3%84-%EC%9B%90%EC%B9%99-solid)





## 2장. 의미 있는 이름

소프트웨어에서 이름은 어디에서나 쓰입니다. 이름을 잘 지으면 여러모로 편하기 때문에 이 장에서는 이름을 잘 짓는 간단한 규칙 몇 가지를 소개한다고 합니다.





### 2-1. 의도를 분명히 밝혀라

**좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많습니다.** 때문에 변수나 함수 그리고 클래스 이름은 다음과 같은 굵직한 질문에 모두 답해야 합니다.

- **변수(혹은 함수나 클래스)의 존재 이유는?**
- **수행 기능은?**
- **사용 방법은?**

만약 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말입니다.



#### 코드

```java
public List<int[]> getThen() {
  List<int[]> list1 = new ArrayList<int[]>();
  
  for (int[] x : theList)
    if (x[0] == 4)
      list1.add(x);
  
  return list1;
}
```

위의 코드는 복잡하진 않지만 짐작하기는 어렵습니다. 그 이유는 읽는 사람이 다음과 같은 정보를 안다고 가정하기 때문입니다.

1. theList에 무엇이 들었는가?
2. theList에서 0번째 값이 어째서 중요한가?
3. 값 4는 무슨 의미인가?
4. 함수가 반환하는 리스트 list1을 어떻게 사용하는가?

`지뢰찾기` 게임을 만든다고 가정하고 위의 코드를 조금 더 파악하기 쉽게 바꿔보겠습니다.

```java
public List<int[]> getFlaggedCells() {
  List<int[]> flaggedCells = new ArrayList<int[]>();
  
  for (int[] cell : gameBoard) // theList -> gameBoard
    if (cell[STATUS_VALUE] == FLAGGED) // 0을 STATUS_VALUE이라는 상수로 4를 FLAGGED라는 상수로 이름을 붙여줌
      flaggedCells.add(cell);
  
  return flaggedCells;
}
```

**각 개념에 이름만 붙여도 코드가 상당히 나아집니다.** 여기서 아래와 같이 int배열을 사용하는 대신 `Cell` 클래스를 만들고 `isFlagged`라는 좀 더 명시적인 함수를 사용해 상수 값들을 감춰도 좋습니다.

```java
// int[]을 Cell로 클래스로 변경
public List<Cell> getFlaggedCells() {
  List<Cell> flaggedCells = new ArrayList<Cell>();
  
  for (Cell cell : gameBoard)
    if (cell.isFlagged) // isFlagged를 만들어 상수 값을 감춤
      flaggedCells.add(cell);
  
  return flaggedCells;
}
```





### 2-2. 그릇된 정보를  피하라

- **약어를 사용하지 않습니다.**
  - ex) 직각삼각형의 빗변(hypotenuse)를 hp라 표현하는 등...
- **예약어를 사용하지 않습니다.**
  - ex) 실제 List가 아니라면 여러 여러 계정 그룹을 `accountList`라 명명하지 않고 `accountGroup` 등으로 표현
  - List인 경우라도 컨테이너 유형을 이름에 넣지 않는 편이 바람직하다고 합니다.
- **서로 흡사한 이름을 사용하지 않도록 주의합니다.**





### 2-3. 의미 있게 구분하라

동일한 범위 안에서는 다른 두 개념에 같은 이름을 사용하지 못합니다. 즉, **이름이 달라야 한다면 의미도 달라져야 한다는 것**입니다. `불용어`를 추가하는 방식은 적절하지 못합니다. **불용어는 a, an, the와 같이 분석에 큰 의미가 없는 단어를 지칭하기 때문에 아무런 정보도 제공하지 못합니다.** 예시는 아래와 같습니다.

- a1, a2 등등...
- ProductInfo 혹은 ProductData
  - `Info, Data`는 a, an, the와 마찬가지로 의미가 불분명하다고 합니다.

그렇다고 a, the 같은 접두어를 사용하지 말라는 소리는 아닙니다. 의미가 분명히 다르다면 사용해도 무방합니다.

#### 나의 생각

기존에 불용어를 사용하면 안된다는 것은 알았지만, `Info, Data`는 처음 알았는데, 충분히 오해할만한 소지가 있다고 생각합니다.





### 2-4. 발음하기 쉬운 이름을 사용하라

발음하기 어려운 이름은 사람마다 발음하는 방식도 다르고 토론을 할 때나 새로운 개발자에게 설명이 필요하기 때문에 좋지 않습니다.





### 2-5. 검색하기 쉬운 이름을 사용하라

`MAX_CLASSES_PER_STUDENT`는 검색으로 찾기 쉽지만, 숫자 7은 파일 이름이나 수식이 모두 검색되기 때문에 검색으로 찾기가 쉽지 않습니다. 아래의 두 예제를 비교해 보겠습니다.



#### 예제1

첫 번째 예제입니다. 각 변수가 어떤 걸 의미하는지도 모르겠고 검색할 때도 너무 힘들 것 같습니다.

```java
for (int j=0; j<34; j++) {
	s += (t[j]*4)/5;
}
```



#### 예제2

두 번째 예제입니다. 코드가 조금 길어졌지만, 검색하기도 용이하고 변수명으로 어떤 걸 의미하는지 파악할 수 있습니다.

```java
int realDayPerIdealDay = 4;
const int WORK_DAYS_PER_WEEK = 5;
int sum = 0;
for (int j=0; j < NUMBER_OF_TASKS; j++) {
  int realTaskDays = taskEstimate[j] * realDayPerIdealDay;
  int realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK);
  sum += realTaskWeeks;
}
```





### 2-6. 인코딩을 피하라

이름에는 인코딩할 정보가 아주 많은데, 여기에 유형이나 범위 정보까지 인코딩에 넣으면 그만큼 이름을 해독하기 어려워집니다. 아래의 몇 가지 예시를 보겠습니다.

- `헝가리식  표기법`
  - 과거에는 컴파일러가 타입을 점검하지 않았으므로 프로그래머에게 타입을 기억할 단서가 필요했습니다.
  - 현재는 **IDE가 코드를 컴파일하지 않고도 타입 오류를 감지할 정도로 발전했기 때문에 헝가리 표기법이나 기타 인코딩 방식은 오히려 방해**가 됩니다.
- `멤버 변수 접두어`
  - 멤버 변수를 다른 색상으로 표시하거나 눈에 띄게 보여주는 IDE가 많기 때문에 굳이 사용할 필요가 없습니다.
- `인터페이스 클래스와 구현 클래스`
  - 인터페이스와 구현 클래스를 작성할 때 인코딩이 필요한 경우가 있는데, 이런 경우에는 인터페이스에 I를 붙여주거나, 구현 클래스에 Imp를 붙여줄 수 있는데 저자는 Imp가 더 좋다고 합니다.
  - ex) 도형을 생성하는 `ShapeFactory`와 `ShapeFactoryImp`



#### 나의 생각

인터페이스 클래스와 구현 클래스 부분은 스타일 차이라고 생각은 되지만, **Imp가 I를 붙이는 것 보다는 가독성이 좋다고 생각**합니다.





### 2-7. 자신의 기억력을 자랑하지 마라

코드를 분석하는 사람이 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면 그 변수 이름은 바람직하지 못합니다. 예를 들면, **r이라는 변수가 호스트와 프로토콜을 제외한 소문자 URL이라는 사실을 자기만 기억하고 사용하지 말라는 의미**입니다. (루프에서 사용하는 단일 이름으로 된 변수는 괜찮다고 합니다. 가독성이 좋지 않은 소문자 L 제외)





### 2-8. 클래스 이름

클래스 이름과 객체 이름은 명사나 명사구가 적합합니다. `Customer, WikiPage, Account` 등등..



#### 나의 생각

`Manager, Processor, Data, Info` 같은 단어를 피하라고 하는데.. `Data, Info`는 너무 추상적이니 이해는 가지만 `Manager, Processor`는 왜 피해야 하는지 모르겠습니다.





### 2-9. 메서드 이름

- 메서드 이름은 동사나 동사구가 적합합니다. `postPayment, deletePage` 등등...

- `접근자, 변경자, 조건자`는 javabean 표준에 따라 값 앞에 `get(접근자), set(변경자), is(조건자)`를 붙입니다.
- 생성자를 중복정의(overload) 할 때는 정적 팩토리 메서드를 사용합니다. (메서드는 인수를 설명하는 이름을 사용합니다.)
  - `Complex fulcrumPoint = Complex.FromRealNumber(23.0);`의 코드가 아래의 코드보다 좋습니다.
  - `Complex fulcrumPoint = new Complex(23.0);`
- 생성자 사용을 제한하려면 해당 생성자를 private으로 선언합니다.





### 2-10. 기발한 이름을 피하라

당연한 소리긴 하지만.. 이름이 너무 기발하면 알아듣지 못 할수도 있기 때문에 농담식의 이름보다는 의도를 분명하고 솔직하게 표현하는 것이 좋습니다.





### 2-11. 한 개념에 한 단어를 사용하라

추상적인 개념 하나에 단어 하나를 선택해 이를 고수합니다. 예를 들어, 똑같은 메서드를 클래스마다 `fetch, retrieve, get`으로 제각각 부르면 혼란스럽습니다. 마찬가지로 동일 코드 기반에 `Controller, Manager, Driver`를 섞어 쓰면 비슷 비슷한 의미이기 때문에 혼란스럽습니다.



#### 나의 생각

`Controller, Manager, Driver`가 헷갈릴 수 있지만, **MVC 패턴을 사용하는 웹 개발자의 입장에서는 조금 다를 수 있다고 생각**합니다. 때문에 이 부분은 분야마다 다를 수 있다고 생각됩니다.





### 2-12. 말장난을 하지 마라

한 단어를 두 가지 목적으로 사용하지 말아야 합니다. 다른 개념에 같은 단어를 사용한다면 그것은 말장난에 불과합니다.

여러 클래스에 `add`라는 메서드가 있을 때, 모든 `add` 메서드의 매개변수와 반환값이 의미적으로 똑같다면 문제 없습니다. 하지만 종종 프로그래머들은 같은 맥락이 아닌데도 `일관성`을 고려해 `add`라는 단어를 선택합니다. 아래와 같은 두 개의 `add` 메서드가 있다고 가정하겠습니다.

- `기존의 add 메서드` : 기존 값 두 개를 더하거나 이어서 새로운 값을 만드는 메서드
- `두 번째 add 메서드` : 집합에 값을 하나 추가하는 메서드

`두 번째 add 메서드`를 add라 불러도 괜찮을까요?? 일관성을 위해 add라 부를수도 있지만, **두 번째 add 메서드는 기존의 add 메서드와 맥락이 다르기 때문에 insert나 append라는 이름이 적합**합니다. 즉, **두 번째 메서드를 add라고 부른다면 말장난인 것**입니다.





### 2-13. 해법 영역에서 가져온 이름을 사용하라

모든 이름을 도메인 영역에서 가져오는 정책은 같은 개념을 다른 이름으로 이해할 수 있어 매번 고객에게 의미를 물어봐야 하기 때문에 좋지 않습니다. **코드를 읽을 사람도 프로그래머이기 때문에 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어등을 사용해도 괜찮습니다.** 프로그래머에게 익숙한 기술 개념은 아주 많기 때문에 **기술 개념에는 기술 이름이 가장 적합한 선택**입니다.





### 2-14. 문제(도메인) 영역에서 가져온 이름을 사용하라

하지만 `적절한 프로그래머 용어`가 없다면 도메인 영역에서 이름을 가져옵니다. 그러면 **코드를 보수하는 프로그래머가 도메인 전문가에게 의미를 물어 파악**할 수 있습니다. 다만 **우수한 프로그래머와 설계자라면 해법 영역과 문제(도메인) 영역을 구분할 줄 알아야 합니다.**





### 2-15. 의미 있는 맥락을 추가하라

모든 이름은 스스로 의미를 가지지만 대다수 이름은 그렇지 못합니다. 때문에 **클래스, 함수, 이름 공간에 넣어 맥락을 부여합니다. 이 모든 방법이 실패했을 때, 마지막 수단으로 접두어를 붙입니다.**
예를 들어, 주소에 속하는 `addrFirstName, addrLastName, addrState`가 있습니다. 접두어 `addr`을 추가하므로써 코드를 읽는 사람이 주소에 속한다는 것을 알 수있습니다. 물론 Adress라는 클래스를 생성하면 더 좋습니다. 아래의 두 예제를 비교하면서 좀 더 확실히 알아보겠습니다.



#### 예제1

해당 예제는 메서드 이름에서 통계 추측 메세지를 출력한다는 것을 알수는 있지만, 함수를 끝까지 읽어보고 나서야 `number, verb, pluralModifier`라는 변수 세 개가 `통계 추측 메세지`에 사용된다는 사실을 알 수 있습니다.

```java
private void printGuessStatistics(char candidate, int count) {
	String number;
	String verb;
	String pluralModifier;
	
	if (count == 0) {
		number = "no";
		verb = "are";
        pluralModifier = "s";
	} else if (count == 1) {
        number = "1";
        verb = "is";
        pluralModifier = "";
	} else {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }
    
    String guessMessage = String.format(
        "There %s %s %s%s", verb, number, candidate, pluralModifier
    );
}
```



#### 예제2

위의 함수를 작은 조각으로 쪼개어 세 변수를 가지는 `GuessStatisticsMessage`라는 클래스를 만듭니다. 그러면 **세 변수는 맥락이 분명해지고 함수를 쪼개기가 쉬워지므로 알고리즘도 좀 더 명확**해집니다.

```java
public class GuessStatisticsMessage {
    private String number;
    private String verb;
    private String pluralModifier;
    
    public String make(char candidate, int count) {
        createPluralDependentMessageParts(count);
        return String.format(
        	"There %s %s %s%s", verb, number, candidate, pluralModifier
        );
    }
    
    private void createPluralDependentMessageParts(int count) {
        if (count == 0) {
            thereAreNoLetters();
        } else if (count == 1) {
            thereIsOneLetter();
        } else {
            thereAreManyLetters(count);
        }
    }
    
    private void thereAreManyLetters(int count) {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }
    
    private void thereIsOneLetter() {
        number = "1";
        verb = "is";
        pluralModifier = "";
    }
    
    private void thereAreNoLetters() {
        number = "no";
		verb = "are";
        pluralModifier = "s";
    }
}
```





### 2-16. 불필요한 맥락을 없애라

`(Gas Station Deluxe)고급 휘발유 충전소`라는 애플리케이션을 짠다고 가정합니다. 

만약 모든 클래스 이름을 `GSD`로 시작한다면 IDE에서 G를 입력하고 자동 완성 키를 누르면 IDE는 모든 클래스를 열거하게 되므로 좋지 않습니다. 또 다른 프로그램에서 해당 객체를 사용하는 경우가 생기면 `GSD`가 붙는 객체는 사용하기에 적절하지 않습니다.

일반적으로는 의미가 분명한 경우에 짧은 이름이 긴 이름보다 좋습니다. 때문에 불필요한 맥락을 제거해야하고 이름을 정할 때 의미가 분명하게 만들어야합니다.





### 2-17. 2장을 마치며...

우리들 대다수는 자신이 작성한 클래스 이름과 메서드 이름을 모두 암기하지 못합니다. 때문에 **우리는 문장이나 문단처럼 읽히는 코드나 표나 자료 구조처럼 읽히는 코드를 작성하는데 집중**해야 합니다. 만약 코드 개선 노력과 마찬가지로 이름 역시 나름대로 바꿨다가는 누군가의 질책을 받을지도 모르지만 그렇다고 **코드를 개선하려는 노력을 중단해서는 안 됩니다.**





---

참고 : Clean Code - 로버트 C. 마틴

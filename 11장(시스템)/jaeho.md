## 11장 시스템

>  "복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다."

---

 ### 1. 도시를 세운다면?

- 도시를 세운다면, 혼자서의 힘으로 관리하고 세울 수 없다. 각 분야를 담당하는 관리하는 팀이 존재하며, 큰 그림을 그리는 사람이 있고 작은 사항에 집중하는 사람도 있기 때문이다. ==> 소프트웨어 시스템도 마찬가지이다❗️
- 하지만 다양한 팀이 활동하기에 비슷한 수준으로 관심사를 분리하거나, 추상화를 이뤄내지 못하는 상황. ==> _But_ , 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다. 

---

### 2. 시스템 제작과 시스템 사용을 분리하라.

- 제작(Contruction) 과 사용(Use)은 아주 다르다는 점을 명심하라!

  > 즉, 어플리케이션 객체를 제작하고 의존성을 서로 연결하는 __준비과정__ 과 준비과정 이후에 이어지는 __런타임로직__ 을 분리하라.

- 관심사의 분리(준비과정과 런타임로직을 나누는 것)는 가장 오래되고 가장 중요한 설계 기법 중 하나이다.

```java
// 준비과정 코드와 런타임 로직을 섞어 놓은 예제.
public Service getService() {
  if (service == null)
		service = new MyServiceImpl(...);
  return service;
}

// 위의 예제는 초기화 기법를 적용한 사례이다. 이와 같은 초기화 기법으로 얻는 장점이 있다.
// 1. 실제로 필요할 때까지 객체를 생성하지 않으므로, 불필요한 부하가 걸리지 않는다. ==> 어플리케이션의 시작시간이 빨라짐
// 2. 어떠한 경우에도 null 포인터를 반환하지 않는다.

// 그러나, 단점 또한 존재한다.
// 1. getService 메서드가 MyServiceImpl + 생성자 인수에 명시적으로 의존한다. ==> 객체를 사용하지 않더라도 의존성을 해결하지 못하면 컴파일x
// 2. 테스트를 진행한다면, 테스트 전용 객체(TEST DOUBLE, MOCK OBJECT)를 service에 할당해야 된다.
// 3. 또한 service가 null인 경우 + service가 null이 아닌 경우, 2가지 경우에 대해 테스트를 진행해야 한다. ==> 단일 책임 원칙 위반!
// 4. 결정적으로, MyServiceImpl이 모든 상황에 적합한 객체인지 모른다.
```

> _초기화 지연(Lazy Initialization):_ 초기화 지연(lazy initialization)은 클래스, 필드 등을 사용하는 시점에 초기화를 하는 기법. 대부분의 경우에는 초기화 지연보다는 일반적으로 클래스를 생성하면서 초기화 하는 것이 좋습니다. 초기화 비용이 크고, 내부적으로 필드 사용 빈도가 적다면 초기화 지연이 적절합니다.
>
> 출처: https://duzi077.tistory.com/258 [개발하는 두더지]

> _Test Double 테스트더블_ : xUnit Test Patterns"의 저자인 제라드 메스자로스(*Gerard Meszaros*)가 만든 용어로 테스트를 진행하기 어려운 경우 이를 대신해 테스트를 진행할 수 있도록 만들어주는 객체를 말한다. 
>
> 출처: https://tecoble.techcourse.co.kr/post/2020-09-19-what-is-test-double/
>
> _Mock Object 모의 객체_ :  주로 객체 지향 프로그래밍으로 개발한 프로그램을 테스트 할 경우 테스트를 수행할 모듈과 연결되는 외부의 다른 서비스나 모듈들을 실제 사용하는 모듈을 사용하지 않고 실제의 모듈을 "흉내"내는 "가짜" 모듈을 작성하여 테스트의 효용성을 높이는데 사용하는 객체이다.
>
> 참고: https://medium.com/@SlackBeck/mock-object%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-85159754b2ac

- 위와 같은 예제에서 사용되는 초기화 지연 기법이 한 번 정도 사용되는 것은 문제가 아니다. ==> 그.러.나, 이런 설정 기법을 수시로 사용한다면? 어플이케이션 곳곳에 흩어져, 모듈성이 저조해지고 대게 중복이 심한 경우가 많다.

- 체계적이고 탄탄한 시스템을 만들고 싶다면, __모듈성을 높이면서, 전반적이며 일관적인 방식을 적용하라.__

- 책에서는 모듈성을 높이는 방법으로 다음 방법을 언급한다.

  - 초기화 지연 기법 같은 손쉬운 기법으로 모듈성을 낮추지 마라.
  - 설정 논리와 일반 실행 논리를 분리하라.

  > _모듈성_ :
  >
  > - 구성 요소 변경이 용이한 정도
  > - 모듈로 서로 분리되어 작성되는 성질
  > - 하드웨어 또는 소프트웨어를 추가/변경할 때, 전체에 영향 없이 일부만 바꿀 수 있도록 설계됨

- __Main 분리__

- ![image-20220206204111623](/Users/user/Library/Application Support/typora-user-images/image-20220206204111623.png)

  - 시스템 생성과 시스템 사용을 분리하는 한 가지 방법

  - 생성과 관련한 코드는 모두 `main` 이나, 이를 호출하는 모듈로 옮기고 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다. ==> 즉, 어플리케이션은 main이나 객체가 생성되는 과정은 모르며, 단지 모든 객체가 적절히 생성되었고 가정한다.

  - `main` 함수에서는 시스템에 필요한 객체를 생성하고 이를 어플리케이션에 넘긴 뒤, 어플리케이션은 그 객체를 사용하기만 하므로 제어 흐름을 따라가기 쉽다.

- __팩토리__

- ![image-20220206204215667](/Users/user/Library/Application Support/typora-user-images/image-20220206204215667.png)

  - 팩토리 분리는 객체가 생성되는 시점을 어플리케이션이 결정한다.
  - ABSTRACT FACTORY 패턴을 사용하여, LineItem 인스턴스의 생성시점은 어플리케이션이 결정하지만 LineItem코드는 어플리케이션이 알지 못한다.
  - 마찬가지로, main에서 OrderProcessing 어플리케이션으로 의존성이 향하며 이 어플리케이션은 LineItem이 생성되는 구체적인 방법은 모른다. 그러나, 어플리케이션은 LineItem 인스턴스가 생성되는 시점을 통제할 수 있다.

  > 추상 팩토리 패턴: 서로 관련이 있는 객체들을 통째로 묶어서 팩토리 클래스로 만들고, 이들 팩토리를 조건에 따라 생성하도록 다시 팩토리를 만들어서 객체를 생성하는 패턴
  >
  > 참고: https://victorydntmd.tistory.com/300

- __의존성 주입__

  - 제어 역전(Inversion of Control, IoC) 기법을 의존성 관리에 적용한 메커니즘

- > 제어 역전: 오브젝트 생성, 관계설정, 사용, 제거 등 **오브젝트 전반**에 걸친 모든 **제어권**을 애플리케이션이 갖는게 아니라 **프레임워크의 컨테이너에게 넘기는 개념**을 말한다. 참고로 스프링 프레임워크 만의 개념이 아니다. 스프링에서 저 오브젝트를 "빈 Bean"이라 칭한다.
  >
  > 참고: https://beststar-1.tistory.com/33

  - 제어의 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘기고, 이 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙(Single Prsponsibility Principle)을 지키게 된다. ==> 즉, 의존성 자체를 인스턴스로 만드는 것이 아닌, 다른 메커니즘에 넘김으로서 '제어를 역전' 하는 것이다.

---

### 3. 확장

- 소프트웨어 시스템은 물리적인 시스템과는 다르게, 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

- 영속성과 같은 관심사는 어플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다. ==> 즉, 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다. (전반적이고, 일관적이여야 한다.)

- __AOP 관점지향프로그래밍__ 에서는 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다는 개념을 가지고 있다.

  - 자바에서 사용하는 관점 혹은 이와 유사한 메커니즘은 대표적으로 _프록시_, _순수 AOP_ , _Asprect J_ 가 있다.

- __3-1. 자바 프록시__

  > 프록시(proxy): 일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스이다. 프록시는 어떠한 것(이를테면 네트워크 연결, 메모리 안의 커다란 객체, 파일, 또 복제할 수 없거나 수요가 많은 리소스)과도 인터페이스의 역할을 수행할 수 있다.
  >
  > 참고: https://m.blog.naver.com/gracefulife/220650929598

  - 프록시는 단순한 상황에 적합하며, 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예이다.
  - 코드의 양과 크기는 프록시의 두 가지 단점으로 꼽힌다. ==> 깨끗한 코드를 작성하기 어렵다.
  - 또한, 시스템 단위로 실행 지점을 명시하는 메커니즘도 제공하지 않는다.

- __3-2. 순수 자바 AOP 프레임워크__

  - 스프링 AOP, JBoss AOP 등의 여러 자바 프레임워크도 내부적으로 프록시를 이용한다.
  - 순수하게 도메인에 초점을 맞추며, 테스트가 더 쉽고 간단하다. ==> 상대적으로 단순하기 때문에 사용자 스토리를 올바로 구현하기 쉬우며 코드를 보수하고 개선하기 편하다.

  > POJO: **Plain Old Java Object**, 간단히 **POJO**는 말 그대로 해석을 하면 오래된 방식의 간단한 [자바](https://ko.wikipedia.org/wiki/자바_(프로그래밍_언어)) 오브젝트라는 말로서 [Java EE](https://ko.wikipedia.org/wiki/Java_EE) 등의 중량 [프레임워크](https://ko.wikipedia.org/wiki/프레임워크)들을 사용하게 되면서 해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용되게 된 용어이다.
  >
  > 참고: https://siyoon210.tistory.com/120

- __3-3. AspectJ 관점__

  - 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다.
  - 사실, 순수 자바 방식은 관점이 필요한 상황 중 80~90%가 충분하다.
  - AspectJ는 이는 관점을 분리하는 강력하고 풍부한 도구 집합을 제공하지만, 새 도구를 사용하고 새 언어 문법과 사용법을 익혀야 한다는 단점이 있다.

---

### 4. 테스트 주도 시스템 아키텍처 구축

- 소프트웨어 아키텍처는 BDUF(Big Design Up Front) 개발 방법론 보다는 Agile 방식을 통해 더 효과적이고 효율적인 확장을 이뤄 나갈 수 있다.

> BDUF(=폭포수 모델) 참고: https://atoz-develop.tistory.com/entry/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%AA%A8%EB%8D%B8-%ED%8F%AD%ED%8F%AC%EC%88%98-%EB%AA%A8%EB%8D%B8Waterfall-Model

> 애자일 모델 참고: https://m.blog.naver.com/sundooedu/221193074730

- 그렇다고 무작정 프로젝트에 뛰어드는 것이 아닌, 일반적인 범위와 목표, 일정, 결과의 구조를 생각해야 한다. 그러면서 함께 변하는 환경에 대처해 변경할 능력을 유지해야 한다.

---

### 5. 의사 결정을 최적화 하라

- 아주 큰 시스템에서는 한 사람이 모든 결정을 내리기 어렵다. ==> 가장 적합한 사람에게 책임을 맡기면 가장 좋다.
- 가능한 마지막 순간까지 결정을 미루는 방법. ==> 최대한 정보를 모아 최선의 결정을 내리자.

---

### 6. 명백한 가치가 있을 때 표준을 현명하게 사용하라.

- 건축은 성숙한 사업이기에, 여러 세기를 거쳐 최적화된 부품과 방법, 표준이 존재한다. ==> 이를 통해 빠른 성장과 구축을 이루었다.
- 소프트웨어에서도 표준을 사용하여 재사용성, 적절한 경험의 개발자, 아이디어 도출을 얻을 수 있다. ==> 그러나 때로는 표준을 만드는 시간이 오래걸리는 상황하여 악영향을 미칠 수 있다.

---

### 7. 시스템은 도메인 특화 언어가 필요하다.

- 좋은 DSL(Domain Specific Languages)은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 의사소통 틈을 줄여준다. ==> 개발자가 적절한 추상화 수준에서 코드 의도를 표현할 수 있다.

> [도메인 특화 언어 - JetBrain](https://www.jetbrains.com/ko-kr/mps/concepts/domain-specific-languages/)
>
> 도메인 특화 언어(Domain - Specific - Languages) :  특정 분야에 최적화된 프로그래밍 언어이다. 해당 분야 또는 도메인의 개념과 규칙을 사용한다. SQL이나 HTML 같은 언어가 있다. => 반대어로는 범용어인데, C / Java 와 같은 프로그래밍 언어를 말한다.
>
> 장점: 언어의 구조가 안정적이라면, 그 분야의 사람들이 코드를 이해하는 데 불편함이 없다, 또한 프로그래밍 코드의 양이 적고 가독성이 높다.
>
> 단점: 설계가 잘 이루어지지 않는다면, 읽기 어려운 코드가 될 수 있다.

---

### 결론

- 시스템은 깨끗해야 한다.
- 도메인 논리가 흐려지면 제품 품질이 떨어진다.
- 모든 추상화 단계에서 의도는 명확히 표현해야 한다.
- __시스템은 실제로 돌아가는 가장 단순한 수단을 사용해야 한다__
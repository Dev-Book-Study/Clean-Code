## 13. 동시성

> - 스레드를 동시에 돌리는 이유를 논하자.
> - 여러 스레드를 동시에 돌리는 어려움에 대해 논하자.
> - 이 어려움에 대처하고 깨끗한 코드를 작성하는 방법에 대해 제안한다.
> - 동시성을 테스트하는 방법과 문제점을 논하자.

---

### 1. 동시성이 필요한 이유

- 동시성은 결합(Coupling)을 없애는 전략이다. ==> 무엇과 언제를 분리하는 전략!

> __[결합도](https://ko.wikipedia.org/wiki/%EA%B2%B0%ED%95%A9%EB%8F%84) (Coupling, = 의존도)__ : 어떤 모듈이 다른 모듈에 의존하는 정도를 나타내는 단어. 반대로는 응집도가 있다.

- 단일 스레드로 구성된 프로그램은 "무엇"과 "언제"가 밀접하다. ==> 호출하는 스택(언제)를 살펴보면 상태(무엇)가 직관적으로 보인다.
- 어플리케이션에서는 _무엇_ 과 _언제_ 를분리하면 구조와 효율이 극적으로 나아진다. ==> 전체 프로그램이 작은 프로그램이 여럿으로 구성되어 보이고, 이에 따른 문제도 해결하기 쉽다.
- 응답시간과 작업 처리량을 생각하면 동시성 구현이 불가피하다. ==> ex) 웹사이트 크롤링 / 사용자 처리 시스템 / 대량 정보 분석

#### 1-1. 미신과 오해

- 동시성이 필요한 상황은 존재하지만, 주의하지 않으면 난감한 상황에 빠진다.
- _동시성에 관한 일반적인 미신과 오해_
  1. 동시성은 항상(x) 성능을 높여준다. ==> 동시성은 때로(o) 성능을 높여준다.
     - 대기시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 할 수 있는 경우 / 여러 프로세서가 동시에 처리할 독립적인 상황이 충분히 많은 경우
  2. 동시성을 구현해도 설계는 변하지 않는다.
     - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 많이 다르다.
  3. 웹 또는 EJB(Enterprise Java Bean) 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
     - 실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 파악해야한다.
- _동시성에 관련한 타당한 생각_
  1. 동시성은 다소 부하를 유발한다. ==> 성능 측면에서 부하가 걸리며, 코드도 더 짜야한다.
  2. 동시성은 복잡하다.
  3. 일반적으로 동시성 버그는 재현하기 어렵다. ==> 그래서 진짜 결함보다는, 일회성 문제로 여겨 무시하기 쉽다.
  4. 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다. ⤵️

---

### 2. 난관

```java
public class X {
  private int lastIdUsed;
  
  public int getNextId() {
    return ++lastIdUsed;
  }
}

/*
인스턴스X 를 생성하고 lastIdUsed 필드를 42로 설정하면 두 스레드는 해당 인스턴스를 공유한다. 이 때, 두 스레드가 getNextId(); 를 호출하면?
1. 스레드1은 43, 스레드2는 44, lastIdUsed는 44가 되는 경우
2. 스레드1은 44, 스레드2는 43, lastIdUsed는 44가 되는 경우
3. 스레드1은 43, 스레드2는 43, lastIdUsed는 43이 되는 경우
*/
```

- 두 스레드가 같은 변수를 동시에 참조하면 세 번째와 같이 놀라운 결과가 발생한다. ==> 두 스레드가 코드 한 줄을 거치는 경로는 수없이 많은데, 그 중에 잘못된 경우가 발생할 수 있다.(즉, 잘못된 결과를 내놓는 일부 경로)

> 경로의 수는 (T * N)! / (N! ** T) , 스레드 2개와 바이트(8)를 기준으로 (2 * 8)! / (8! ** 2) = 12870

---

### 3. 동시성 방어 원칙

#### 3-1. 단일 책임 원칙 (Single Responsibility Principle)

- 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙 ==> 동시성은 복잡성 하나만으로 따로 분리할 이유가 충분하다. 즉, 동시성 관련 코드는 다른 코드와 분리해야 한다는 뜻.
- 동시성을 구현할 때 고려해야 할 몇 가지
  1. 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
  2. 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다.
  3. 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.
- __동시성 코드는 다른 코드와 분리하라!__

#### 3-2. 자료 범위를 제한하라

- 예상치 못한 결과를 내놓는 문제를 해결하기 위한 방안으로, 공유 객체를 사용하는 코드 내 _임계영역_ 을 키워드로 보호하라 ==> 임계영역의 수를 줄이는 기술이 필요하다.

> 임계영역(Critical Section): 프로세스간의 공유자원을 접근하는데 있어서 문제가 발생하지 않도록, 한번에 하나의 프로세스만 이용하게끔 보장해줘야 하는 영역
>
> 참고: https://hombody.tistory.com/240

- 공유 자료를 수정하는 위치가 많을 수록
  - 보호할 임계영역을 빼먹는다. ==> 공유자료를 수정하는 모든 코드를 망가뜨린다.
  - 모든 임계영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다. (DRY, Don't Repeat Yourself 위반)
  - 그렇지 않아도 찾아내기 어려운 버그가 더욱 찾기 어려워진다.

#### 3-3. 자료 사본을 사용하라.

- 경우에 따라서는 객체를 복사해 읽기 전용으로 사용하는 방법과 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다.
- 객체를 복사하는 시간과 부하가 걱정스러울 수 있지만 그 때에는, 복사 비용이 진짜 문제인가를 생각해볼 필요가 있다. 

#### 3-4. 스레드는 가능한 독립적으로 구현하라.

- 다른 스레드와 자료를 공유하지 않는 자신만의 세상에 존재하는 스레드를 구현하라 ==> 하나의 스레드는 클라이언트 요청 하나를 처리하라.
- 즉, 독자적인 스레드로, 가능하면 다른 프로세서에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.

---

### 4. 라이브러리를 이해하라.

- 자바 5로 스레드 코드를 구현한다면 다음을 고려해보라
  - 스레드 환경에 안전한 컬렉션을 사용한다. (자바 5부터 제공한다)
  - 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다.
  - 가능하다면 스레드가 차단되지 않는 방법을 사용한다.
  - 일부 클래스 라이브러리는 스레드에 안전하지 못하다.
- 언어가 제공하는 클래스를 검토하라. ==> 자바에서는 `java.util.concurrent`, `java.util.concurrent.atomic`, `java.util.concurrent.locks` 를 익혀라.

---

### 5. 실행 모델을 이해하라.

> 기본 용어 이해하기
>
> | 용어                         | 설명                                                         |
> | ---------------------------- | ------------------------------------------------------------ |
> | 한정된 자원 (Bound Resource) | 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 있다. |
> | 상호배제 (Mutual Exclusion)  | 한 번에 한 스레드만 공유 자료나 자원을 사용할 수 있는 경우를 가리킨다. |
> | 기아 (Starvation)            | 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. 예를 들어, 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이어질 경우, 긴 스레드가 기아 상태에 빠진다. |
> | 데드락 (Deadlock)            | 여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다. |
> | 라이브락 (Livelock)          | 락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해, 괸장히 오랫동안 혹은 영원히 진행하지 못한다. |

#### 5-1. 생산자-소비자

- 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원이다.
  - 생산자 스레드는 대기열에 빈 공간이 있어야 정보를 채우고, 소비자 스레드는 대기열에 정보가 있어야 가져온다.
- 생산자 스레드는 대기열에 정보를 채우고 "대기열에 정보가 있다"는 시그널, 소비자 스레드는 대기열의 정보를 사용하고 "대기열에 빈 공간 있다"는 시그널을 보낸다.
  - 잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게 시그널을 기다릴 가능성이 존재한다.

#### 5-2. 읽기-쓰기

- 읽기 스레드를 주된 정보원으로 공유 자원을 사용하고, 쓰기 스레드가 공유 자원을 갱신한다고 가정할 때, 처리율이 핵심이다.
  - 처리율을 강조한다면 기아 현상이 생기거나, 오래된 정보가 쌓인다.
- 쓰기 스레드가 버퍼를 갱신하는 동안 읽기 쓰레드가 버퍼를 쓰지 않고, 반대로 읽기 스레드가 버퍼를 읽는 동안 쓰기 스레드가 버퍼를 갱신하지 않으려면 균형잡기가 필요하다.
  - 간단한 전략으로 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이 있다. ==> 그러나, 읽기 쓰레드가 계속 이어진다면 쓰기 스레드는 기아 상태로 빠질 가능성이 농후
  - 반면, 쓰기 스레드에게 우선권을 준 상태에서 쓰기 스레드가 이어진다면 처리율이 떨어진다.
- 이 문제는 양쪽 균형을 잡으면서 갱신 문제를 피하는 방법이 필요하다.

#### 5-3. 식사하는 철학자들

- 원형 식탁에 철학자들이 앉아있고, 각 철학자들의 왼손에는 포크가 놓여있으며 가운데에는 스파게티가 있다. 이 스파게티를 먹으려면 양손에 포크가 쥐어져야 한다. ==> 계속 먹는 사람이 있는가 하면, 계속 먹지못하는 사람이 생긴다.
- 이 문제를 기업 어플리케이션에 비교해보자. 기업 어플리케이션은 여러 프로세스가 자원을 얻으려 경쟁하며  잘못된 설계에서 데드락, 라이브락, 처리율 저하, 효율성 저하를 겪을 수 있다.

#### 5-4. 결론

- 일상에서 접하는 대다수 다중 스레드 문제는 위의 세가지 중 하나에 속한다.
- 각 알고리즘을 공부하고 해법을 이해해보라.

---

### 6. 동기화하는 메서드 사이에 존재하는 의존성을 이해하라.

- 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.
- 공유 객체 하나에는 메서드 하나만 사용하라.
- 공유 객체 하나에 여러 메서드가 필요한 상황도 생기는데, 아래 3가지 방법을 고려해보자
  1. 클라이언트에서 잠금: 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다. ==> 마지막 메서드를 호출할 때까지 잠금을 유지한다.
  2. 서버에서 잠금: 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현한다. ==> 클라이언트는 이 메서드를 호출한다.
  3. 연결서버: 잠금을 수행하는 중간 단계를 생성한다. "서버에서 잠금" 방식과 유사하지만 원래 서버는 변경하지 않는다.

---

### 7. 동기화하는 부분을 작게 만들어라.

- 자바에서 `synchronized` 키워드를 사용하면 락을 설정한다. ==> 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다.
- 락은 스레드를 지연시키고 부하를 가중시킨다. ==> 그러므로 여기저기서 `synchronized` 문을 남발하는 코드는 바람직하지 않다.
- 임계영역은 반드시 보호해라 (최대한 줄여라) ==> 개수를 줄인다고 크기를 늘린다면 스레드간의 경쟁이 늘어나고 프로그램 성능이 떨어진다.

---

### 8. 올바른 종료 코드는 구현하기 어렵다.

- 영구적으로 돌아가는 시스템과 잠시 돌다 깔끔하게 종료하는 시스템을 구현하는 방법은 다르다.
- 깔끔하게 종료하는 코드는 올바로 구현하기 힘들다 ==> 가장 흔히 발생하는 문제는 데드락이다. (스레드가 오지 않을 시그널을 무한정 기다린다.)

> 예를 들어, 부모 스레드가 자식 스레드를 여러 개 만든 후 모두가 끝나기를 기다렸다 자원을 해제하고 종료하는 시스템이 있다고 하자. 만약 자식 스레드중 하나가 데드락에 걸렸다면 부모 스레드는 영원히 기다리고, 시스템은 영원히 종료하지 못한다.
>
> 또하나의 예로, 부모 스레드는 모든 자식 스레드에게 작업을 멈추고 종료하라는 시그널을 전달한다. 그런데 자식 스레드 중 두 개가 생산자/소비자 관계라면? 생산자 스레드는 바로 종료했지만, 소비자 스레드는 생산자 스레드의 시그널을 무한정 기다린다. 부모 스레드 또한 자식 스레드를 영원히 기다린다.

- 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라. (생각보다 어럽다)

---

### 9. 스레드 코드 테스트하기

- 스레드가 둘 이상인 프로그램은 테스트하기 급격하게 복잡해진다. 
- 문제를 노출하는 테스트 케이스를 작성하라. 즉, 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라. 테스트가 실패하면 원인을 추적하라. 어느 한번 통과한다는 이유로 넘어가는 건 절대로 안된다.
- 아래 몇 가지 구체적인 지침을 참고하라.
  - 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라.
  - 다중 스레드를 고려하지 않는 순차 코드부터 제대로 돌게 만들자.
  - 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라.
  - 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라.
  - 프로세서 수보다 많은 스레드를 돌려보라.
  - 다른 플랫폼에서 돌려보라.
  - 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라.

#### 9-1. 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라.

- 다중 스레드 코드는 때때로 '말이 안 되는' 오류를 일으킨다. ==> 대다수 개발자는 스레드가 다른 코드와 교류하는 방식을 직관적으로 이해 못한다.
- 스레드 코드에 잠입한 버그는 아주 적은 확률로 나타나기도 한다. ==> 실패를 재현하기 아주 어렵다.
- 시스템 실패를 단순한 '일회성' 문제를 치부하지 마라. ==> 일회성 문제를 계속 무시한다면 잘못된 코드에 잘못된 코드가 쌓인다.

#### 9-2. 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자.

- 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인하자.
- 일반적인 방법으로 스레드가 호출하는 POJO(plain old java object, 평범한 자바 객체) 만들어, 스레드 환경 밖에서 테스트하는 방법이 있다. ==> 여기에 넣는 코드는 많을수록 좋다.

#### 9-3. 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라.

- 다중 스레드를 쓰는 코드를 다양한 설정으로 실행하기 쉽게 구현하라.
  - 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔보자.
  - 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
  - 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다.
  - 반복 테스트가 가능하도록 테스트 케이스를 작성한다.
- 즉, 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라.

#### 9-4. 다중 쓰레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라.

- 적절한 스레드 개수를 파악하려면 상당한 시행착오가 필요하다. ==> 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구해라.
- 그러기 위해선, 스레드 개수를 조율하기 쉽게 코드를 구현한다. 또한 프로그램이 돌아가는 도중에 스레드 개수를 변경하는 방법도 고려해보라. 더 나아가, 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민해보자.

#### 9-5. 프로세서 수보다 많은 스레드를 돌려보라.

- 시스템이 스레드를 스와핑할 때도 문제가 발생한다. ==> 스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌린다.
- 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.

> __스와핑(Swapping):__ 프로세스가 실행되기 위해서는 메모리 상에 있어야 하지만 필요한 경우 프로세스는 실행 도중에 임시로 보조 메모리로 교체되어 나갔다가 다시 메모리로 되돌아 올 수가 있다. 이러한 프로세스 교체 과정을 스와핑(swapping)이라고 한다.
>
> 출처: https://neos518.tistory.com/121 [As I've always been]

#### 9-6. 다른 플랫폼에서 돌려보라.

- 다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다. ==> 따라서 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 마땅하다.
- 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라.

#### 9-7. 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라.

- 흔히 스레드 코드는 오류를 찾기가 쉽지 않다. ==> 간단한 테스트로는 버그가 드러나지 않는다.
- 스레드 버그가 산발적이고 우발적이고 재현이 어려운 이유는 코드가 실행되는 수천 가지 경로중 소수만 실패하기 때문이다.
- 이렇게 드물게 발생하는 오류를 좀 더 자주 일으킬 방법으로, 보조 코드를 추가해 코드가 실행되는 순서를 자주 바꾸는 방법이 있다.
  - 예를 들어, `Object.wait()` / `Object.sleep()` / `Object.yield()` / `Object.priority()` 같은 메서드를 추가해 다양한 순서로 실행한다.
  - 각 메서드는 스레드가 실행되는 순서에 영향을 미친다. ==> 버그가 일어날 가능성도 높아진다.
- 잘못된 코드라면 가능한 초반에, 긜고 가능한 자주 실패하는 편이 좋다.
- 코드에 보조 코드를 추가하는 방법은 두 가지 이다.

1. __직접 구현하기__

   - 코드에다 직접 `wait()` / `sleep()` / `yield()` / `priority()` 함수를 추가한다.

   ```java
   public synchronized String nextUrlOrNull() {
     if (hasNext()) {
       String url = urlHenerator.next();
       Thread.yeild();		// 테스트 위해 추가되었다.
       updateHasNext();
       return url;
     }
     return null;
   }
   ```

   - `yield()` 를 삽입하면 코드가 실행되는 경로가 바뀐다. ==> 이전에 실패하지 않았던 코드가 실패할 가능성을 열어준다.
   - 이 방법에는 여러 가지 문제가 있다.
     - 보조 코드를 삽입할 적정 위치를 직접 찾아야 한다.
     - 어떤 함수를 어디서 호출해야 적당한지 어떻게 알까?
     - 배포 환경에 보조 코드를 그대로 남겨두면 프로그램 성능이 떨어진다.
     - 무작위적이다. 오류가 드러날지도 모르고 드러나지 않을지도 모른다. 사실상 드러나지 않은 확률이 더 놓다.

2. __자동화__

   - 보조 코드를 자동으로 추가하려면 AOF, CGLIB, ASM 등과 같은 도구를 사용한다.

   ```java
   public class ThreadJigglePoint {
     public static void jiggle() {
     }
   }
   
   public synchronized String nextUrlOrNull() {
     if (hasNext()) {
       ThreadJigglePoint.jiggle();
       String url = urlHenerator.next();
       ThreadJigglePoint.jiggle();
       updatehasNext();
       ThreadJigglePoint.jiggle();
       return url;
     }
     return null;
   }
   ```

   - `ThreadJigglePoint.jiggle()` 호출은 무작위로 sleep이나 yield를 호출한다. 때로는 아무 동작도 하지 않는다.
   - 하나는 jiggle() 메서드를 비워두고 배포 환경에서 사용한다.
   - 둘째는 무작위로 nop, sleep이나 yield 등을 테스트 환경에서 수행한다. ==> 이 방법으로 수천 번에 이르는 테스트 수천 번 실행하면 스레드 오류가 드러날지 모른다.
   - 코드를 흔드는 이유는 스레드를 매번 다른 순서로 실행하기 위해서이다 ==> 좋은 테스트 케이스와 흔들기 기법은 오류가 드러날 확률을 크게 높혀준다.
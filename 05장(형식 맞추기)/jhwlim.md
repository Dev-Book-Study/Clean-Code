# 📖 5장. 형식 맞추기

## 🔎 요약

- 코드의 형식을 맞추는 목적
  1. 어수선한 코드는 다른 측면도 무성의한 태도로 처리했을 것이라는 인상을 심어주게 된다.
  2. 코드가 바뀌어도 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 이후에도 계속 영향을 미친다.
- 적절한 행 길이를 유지하라.
  - 약 200줄 수준
  - 연관성을 고려하여 빈 행을 활용하고, 적절한 곳에 위치시키자.
- 가로 형식을 맞추어라.
  - 약 120자 수준
  - 가로 정렬이 필요할 정도로 길어진다면 파일을 분리하자.
  - 들여쓰기는 무시하지 말자.

## 🔖 목차

1. [형식을 맞추는 목적](#01-형식을-맞추는-목적)
2. [적절한 행 길이를 유지하라](#02-적절한-행-길이를-유지하라)
3. [가로 형식 맞추기](#03-가로-형식-맞추기)
4. [팀 규칙](#04-팀-규칙)

## 들어가기 전에

- 코드가 술 취한 뱃 사람 한 무리가 짜놓은 듯 어수선해 보인다면 독자들은 프로젝트의 다른 측면도 똑같이 무성의한 태도로 처리했으리라 생각할 것이다. 👉 형식을 깔끔하게 맞춰 코드를 짜야 하는 이유
- 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 한다. 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다. 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 한다. 필요하다면 규칙을 자동으로 적용하는 도구를 활용한다.

## 01. 형식을 맞추는 목적

- 코드 형식은 중요하다. ⚠️ 너무나도 중요하므로 융통성 없이 맹목적으로 따르면 안된다.
- 코드 형식은 의사소통의 일환이다.
- 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다.
- 코드가 바뀌어도 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다. 원래 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지 않는다. 👉 코드의 형식이 중요한 이유 (형식을 맞추는 목적)

## 02. 적절한 행 길이를 유지하라

- 대다수 자바 소스 파일은 크기가 어느 정도일까?
  - FitNesse 프로젝트의 평균 파일 크기는 약 65줄이다. JUnit, FitNesse, Time and Money(tam)는 상대적으로 파일 크기가 작다. 500줄을 넘어가는 파일이 없으며 대다수가 200줄 미만이다.
  - 반면, Tomcat과 Ant는 절반 이상이 200줄을 넘어서고 심지어 수천 줄이 넘어가는 파일도 있다.
  - 500줄을 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다. (FitNesse는 50,000줄에 육박하는 시스템이다.)
- ✅ 저자는 200줄 정도를 반드시 지킬 엄격한 규칙은 아니지만 바람직한 규칙으로 생각한다.
- 일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.

### 1. 신문 기사처럼 작성하라

- ✅ 이름은 간단하면서도 설명이 가능하게 짓는다. 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경 써서 짓는다.
- 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사한다. 마지막에는 가장 저차원인 함수와 세부 내역이 나온다. 👉 [02-5. 세로 순서](#5-세로-순서)

### 2. 개념은 빈 행으로 분리하라

- 패키지 선언부, import 문, 각 함수 사이에 빈 행이 들어간다.
- 빈 행은 새로운 개념을 시작한다는 시각적 단서다.
- ⚠️ 빈 행을 빼버린 코드는 코드 가독성이 현저하게 떨어져 암호처럼 보인다.

### 3. 세로 밀집도

- 세로 밀집도는 연관성을 의미한다.
- ✅ 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다.
- 코드가 '한눈'에 들어온다

### 4. 수직 거리

- 시스템이 무엇을 하는지 이해하고 싶은데, 이 조각 저 조각이 어디에 있는지 찾고 기억하느라 시간과 노력을 소모한다.
- ✅ 서로 밀접한 개념은 세로로 가까이 둬야 한다.
- ✅ 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다. 이게 바로 `protected` 변수를 피해야 하는 이유 중 하나다.
- ℹ️ 연관성이란 한 개념을 이해하는 데 다른 개념이 중요한 정도다. 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다.
- ⚠️ 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스 파일과 클래스를 여기저기 뒤지게 된다.

#### 변수 선언

- ✅ 변수는 사용하는 위치에 최대한 가까이 선언한다.

#### 인스턴스 변수

- ✅ 인스턴스 변수는 클래스 맨 처음에 선언한다. 변수 간에 세로로 거리를 두지 않는다. 클래스 메서드가 인스턴스 변수를 사용하기 때문이다.
- 자바에서는 보통 클래스 맨 처음에 인스턴스 변수를 선언한다.

<details>
<summary>❗️ 자바 변수의 종류</summary>
<div markdown="1">

1. 클래스 변수(class variable)
   - 클래스 영역에 `static`으로 선언된 변수
   - 클래스가 메모리에 올라갈 때 생성된다. (프로그램이 종료될 때까지 유지된다.)
2. 인스턴스 변수(instance variable)
   - 클래스 영역에 선언된 변수
   - 클래스의 인스턴스를 생성할 때 생성된다.
3. 지역 변수(local variable)
   - 메서드 내에 선언된 변수
   - 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸된다.
   - 블럭(`{}`) 내에서만 사용 가능하며, 블럭을 벗어나면 소멸된다.

```java
class Variables {
  static int classVariable; // 클래스 변수
  int instanceVariable; // 인스턴스 변수

  void method() {
    int localVariable = 0; // 지역 변수
  }
}
```

</div>
</details>

<details>
<summary>❗️ 클래스 파일 내 변수 선언 순서</summary>
<div markdown="1">

```java
// 상수 및 클래스 변수

// 인스턴스 변수

// 생성자

// 메서드
```

</div>
</details>

#### 종속 함수

- ✅ 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다. 그러면 프로그램이 자연스럽게 읽힌다.
- 규칙을 일관적으로 적용한다면 독자는 방금 호출한 함수가 잠시 후에 정의되리라는 사실을 예측한다. 호출되는 함수를 찾기가 쉬워지며, 그만큼 모듈 전체의 가독성도 높아진다.

#### 개념적 유사성

- 어떤 코드는 서로 끌어당긴다. 개념적인 친화도가 높기 때문이다. ✅ 친화도가 높을수록 코드를 가까이 배치한다.
- 친화도가 높은 요인

  - 한 함수가 다른 함수를 호출해 생기는 직접적인 종속성이 한 예다.
  - 변수와 그 변수를 사용하는 함수도 한 예다.
  - 비슷한 동작을 수행하는 일군의 함수 : 명명법이 똑같고 기본 기능이 유사하고 간단하다.

    ```java
    // Junit 4.3.1
    public class Assert {
      static public void assertTrue(String message, boolean condition) {
        if (!condition)
          fail(message);
      }

      static public void assertTrue(boolean condition) {
        assertTrue(null, condition);
      }

      static public void assertFalse(String message, boolean condition) {
        assertTrue(message, !condition);
      }

      static public void assertFalse(boolean condition) {
        assertFalse(null, condition);
      }
    }
    ```

### 5. 세로 순서

- 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다.
- ✅ 호출되는 함수를 호출하는 함수보다 나중에 배치한다. 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다.

> 호출하는 함수를 고차원(중요한 개념), 호출되는 함수를 저차원(세세한 사항)이라고 보면 되는지?

## 03. 가로 형식 맞추기

- 한 행은 가로로 얼마나 길어야 적당할까?
  - 프로젝트 7개(JUnit, FitNesse, testNG, Time and Money, JDepend, And, Tomcat)를 조사한 결과가 놀랍도록 규칙적이다. 특히, 45자 근처가 그렇다.
  - 20자에서 60자자 사이인 행이 총 행 수의 40%에 달한다.
  - 10자 미만은 30% 정도로 보인다.
- 프로그래머는 명백하게 짧은 행을 선호한다. 그러므로 짧은 행이 바람직하다.
- 100자나 120자에 달해도 나쁘지 않다. ⚠️ 하지만 그 이상은 솔직히 주의부족이다.
- ✅ 저자는 120자 정도로 행 길이를 제한한다.

### 1. 가로 공백과 밀집도

- 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.

#### (1) 가로 공백을 사용해 밀집도를 표현한 예

```java
private void measureLine(String line) {
    lineCount++;
    int lineSize = line.length();
    totalChars += lineSize;
    lineWidthHistogram.addLine(lineSize, lineCount);
    recordWidestLine(lineSize);
}
```

- 할당 연산자를 강조하려고 앞뒤에 공백을 줬다. 할당문은 왼쪽 요소와 오른쪽 요소가 분명히 나뉜다. 공백을 넣으면 두 가지 주요 요소가 확실히 나뉜다는 사실이 더욱 분명해진다.
- 반면, 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않았다. 함수와 인수는 서로 밀접하기 때문이다. 공백을 넣으면 한 개념이 아니라 별개로 보인다.
- 함수를 호출하는 코드에서 괄호 안 인수는 공백으로 분리했다. 쉼표를 강조해 인수가 별개라는 사실을 보여주기 위해서다.

#### (2) 연산자 우선순위를 강조하기 위해서 공백을 사용한 예

```java
public class Quardratic {
    public static double root1(double a, double b, double c) {
        double determinant = determinant(a, b, c);
        return (-b + Math.sqrt(determinant)) / (2*a);
    }

    public static double root2(int a, int b, int c) {
        double determinant = determinant(a, b, c);
        return (-b - Math.sqrt(determinant) / (2*a));
    }

    private static double determinant(double a, double b, double c) {
        return b*b - 4*a*c;
    }
}
```

- 승수 사이는 공백이 없다. 곱셈이 우선순위가 가장 높기 때문이다.
- 항 사이에는 공백이 들어간다. 덧셈과 뺄셈은 우선순위가 곱셈보다 낮기 때문이다.
- 불행히도, 코드 형식을 자동으로 맞춰주는 도구는 대다수가 연산자 우선순위를 고려하지 못하므로, 수식에 똑같은 간격을 적용한다. 따라서 위와 같이 공백을 넣어줘도 나중에 도구에서 없애는 경우가 흔하다.

### 2. 가로 정렬

- ⚠️ 가로 정렬은 코드의 엉뚱한 부분을 강조해 진짜 의도를 가려지게 한다.
  - 변수 유형은 무시하고 변수 이름부터 읽게 된다.
  - 할당 연산자는 보이지 않고 오른쪽 피연산자에 눈이 간다.
- 정렬을 사용하지 않으면 오히려 중대한 결함을 찾기 쉽다.
- 정렬이 필요할 정도로 목록이 길다면 문제는 목록 길이지 정렬 부족이 아니다.
  - 선언부가 길다면 클래스를 쪼개야 한다.

### 3. 들여쓰기

- 계층에서 각 수준은 이름을 선언하는 범위이자 선언문과 실행문을 해석하는 범위다.
- ℹ️ 범위(scope)로 이뤄진 계층을 표현하기 위해 우리는 코드를 들여쓴다. 들여쓰는 정도는 계층에서 코드가 자리잡은 수준에 비례한다.
- 들여쓰기한 파일은 구조가 한눈에 들어온다. 변수, 생성자 함수, 접근자 함수, 메서드가 금방 보인다.
- ⚠️ 한 행에 범위를 뭉뚱그린 코드를 피한다.

  ```java
  // bad
  public class CommentWidget extends TextWidget {
    public static final String REGEXP = "^#[^\r\n]*(?:(?:\r\n)|\n|\r)?";

    public CommentWidget(ParentWidget parent, String text) {super(parent, text);}
    public String render() throws Exception {return "";}
  }

  // good
  public class CommentWidget extends TextWidget {
    public static final String REGEXP = "^#[^\r\n]*(?:(?:\r\n)|\n|\r)?";

    public CommentWidget(ParentWidget parent, String text) {
      super(parent, text);
    }

    public String render() throws Exception {
      return "";
    }
  }
  ```

### 4. 가짜 범위

- ✅ 빈 while문이나 for문을 피하지 못할 때는 빈 블록을 올바로 들여쓰고 괄호로 감싼다. 세미클론(`;`)은 새 행에다 제대로 들여써서 넣어준다. 그렇게 하지 않으면 눈에 띄지 않는다.

  ```java
  while (dis.read(buf, 0, readBufferSize) != -1)
  ;
  ```

> 중괄호를 이용해서 범위를 명확히 표현하는 것은 어떠한지?

## 04. 팀 규칙

- 팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다.
- 팀은 한 가지 규칙에 합의해야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다.
- ❗️ 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄진다는 사실을 기억하기 바란다. 스타일은 일관적이고 매끄러워야 한다. 한 소스 파일에서 봤던 형식이 다른 소스 파일에도 쓰이리라는 신뢰감을 독자에게 줘야 한다.
- ⚠️ 온갖 스타일을 뒤섞어 소스 코드를 필요 이상으로 복잡하게 만드는 실수는 반드시 피한다.

## References

- <https://www.oracle.com/java/technologies/javase/codeconventions-fileorganization.html>

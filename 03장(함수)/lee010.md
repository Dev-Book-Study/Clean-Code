# 3장 - 함수 : 함수 잘 만드는 법

어떤 프로그램이든 가장 기본적인 단위는 함수다.

## 목표

- 어떻게 해야 읽기 쉽고 이해하기 쉬운 함수를 만들 수 있을까?
- 의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까?
- 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?

# 정리

정리를 시작하기 전 첫번째로 언급되었던 "작게 만들어라.", "내려가기 규칙"을 기본 전제로 이해하는 것이 작가의 의도가 아닐까 생각해봤다. 대부분 내용이 어느정도 연관성이 있는데 그 내용이 위 2가지 규칙 인 것 같다.

---

## 작게 만들어라.

> 함수를 만드는 첫번째 규칙은 '작게!', 두번째 규칙은 '더 작게!' 다.

이 규칙은 증명하기 어렵지만 작가의 경험으로 작은 함수가 더 좋다고 한다.

- 함수가 작을수록 한가지 일만 처리하게 만들기 용이하고 명백해진다.

## 블록과 들여쓰기
> 조건문을 통해 처리될 블록은 한 줄로 표현해야 한다.

블록 안에 들어갈 코드를 함수로 만들어 분리해야 한다. 블록에 들어가게 되는 함수 이름을 적절하게 사용한다면 코드를 이해하기 훨씬 쉬워진다.

또한 이 말은 중첩 구조가 생길만큼 함수가 커져서는 안된다는 뜻으로도 해석 가능하다. 에러한 원칙을 지켜 함수의 들여쓰기 깊이는 2단을 넘지 않게 만드는 것이 좋다.

## 한가지만 해라.
> 함수는 한 가지 일을 해야한다.  
> 그 한가지 일을 잘 해야한다.  
> 그 한가지 일만 해야한다.

추상화 수준이 하나인 단위로 함수를 만들면 하기지 일을 하는 함수를 쉽게 만들 수 있다. 함수를 만드는 이유는 큰 개념(기능) 다음 추상화 수준(세부적으로 해석하여 코드를 만드는 과정)에서 여러 단계(분리된 기능)으로 나눠 수행하기 위해서다. 의미를 유지하면서 더 쪼갤 수 없는 수준까지 줄여가며 분리 해야한다.

### 함수 내 섹션
섹션이 여러개 만들어진다면 함수가 여러개의 일을 한다는 뜻이다. 한가지 일만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

> 평소 코딩을 할 때 변수 선언부와 동작부가 한 묶음으로 만들어지고 순서대로 표현 될 수 있는 경우 분리를 하고 있는데 일맥상통하는 뜻인 것 같다.

## 함수 내 추상화 수준은 하나로
- 이 부분이 내가 실제 적용하기 가장 어려워 하는 내용인 것 같다.

> 함수가 확실히 한 가지 작업만 수행하려면 함수 내 모든 문자으이 추상화 수준(세부적인 표현 단계)이 동일해야 한다.

한 함수 내에 추상화 수준을 섞으면 특정 표현이 근본 개념인지 세부 사항인지 구분하기 어려워, 코드를 읽는 사람이 헷갈린다.

또한 근본 개념과 세부사항을 뒤섞기 시작하면, 깨진 유리창처럼 사람들이 함수에 세부사항을 점점 더 추가한다.

- 이 내용은 높은 수준의 추상화 수준(근본 개념)에, 낮은 레벨의 추상화 수준(세부사항)이 섞여있다면, 수정 할 때 함수를 분리하는 것을 생각하지 않고, 자연스럽게 세부 사항을 추가하게 된다는 뜻 으로 보인다.

## 위에서 아래로 코드 읽기: 내려가기 규칙
코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음(아래)에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아래로 읽히려면 함수 추상화 수준이 한번에 한 단계씩 낮아진다.

- 내려간다는 건 단순히 위에서 아래로 읽힌다는 의미보다, 깊이가 깊어질수록 조금 더 낮은 수준으로 표현되어야 한다는 뜻 같다.

> 추상화 수준이 하나인 함수를 구현하는 것은 어렵다. 핵심은 짧으면서도 한가지 일만 수행하는 함수이다. 한 단계씩 깊어지는 코드를 구현하면 추상화 수준을 일관되게 유지하기 쉬워진다.

## Switch문
> switch문은 작게 만들기 어렵다. (if else 가 반복되는 구현 포함) 본질적으로 switch문은 N 가지를 처리하기 때문이다.

완전히 사용하지 않을 방법은 없기 때문에 다형성을 사용하여 저차원 클래스에 숨기고 반복하지 않아야 한다.

### SOLID : 객체지향 설계 5원칙

- SRP : Single Responsibility Principle, 단일 책임 원칙  
    한 클래스는 하나의 책임만 가져야 한다.

- OCP : Open/Closed Principle, 개방-폐쇄 원칙   
    확장에는 열려 있으나 변경에는 단혀 있어야 한다.

- LSP : Liskov Substituion Principle, 리스코프 치환 원칙  
    객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

- ISP : Interface Segregation Principle, 인터페이스 분리 원칙  
    특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.

- DIP : Dependency Inversion Principle, 의존 관계 역전  
    개발자는 추상화에 의존해야지, 구체화에 의존하면 안된다. 의존성 주입은 을 활용하라.

## 서술적인 이름을 사용하라
> 서술적인 이름은 대부분 함수가 하는 일을 더 잘 표현한다.
코드를 읽으면서 짐작했던 기능을 표현하기 위해 서술적인 이름이 필요한 경우가 있다. (짧게 잘 표현하면 더 좋다.)

이름이 길어도 괜찮다. 
- 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 
- 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
- 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.

### 규칙
- 이름을 붙일 때는 일관성이 있어야 한다
- 모듈 내에서 함수 일므은 같은 문구, 명사, 동사를 사용한다.

## 함수 인수
> 함수 인수는 적을수록 오해를 줄일 수 있다.

인수는 개념을 이해하기 어렵게 만든다. 인수를 사용하게 되면 신경쓸 내용들이 더 많아진다.
- 함수의 인수는 추상화 수준이 다르게 되는 경우가 많은데, 이 때문에 추상화 수준을 일관되게 유지하는 것이 더 어려워 진다.
- 테스트 관점에서 인수가 많을경우 더 다양한 테스트 케이스를 고려해야 한다. 즉, 오동작에 고려해야할 요소가 더 많아질 수 있다.

> 공통 기능을 구현할 때 범용성을 위해 인수를 많이 2개 이상 받게 구현한 경우가 많았는데, 읽고 보니 인터페이스 분리 원칙에 적절하지 않았던 것 같다.   
하지만 강 타입을 지원하는 언어에서 어떤 인수를 받고, 출력하는지 이름으로 명확히 표현할 수 있다고 생각하고, 약 타입 언어도 IDE 성능 개선으로 인해 인수 이름으로 충분히 표현 할 수 있다고 생각하기 때문에 문제가 없다고 보지만, 외부 요인을 줄인다는 목적에서 인수를 적게 유지하는 것은 좋다는 생각이 들었다. 여러 상황을 고려하여 (공통사용이 꼭 필요한가?, 인수를 꼭 받아서 처리해야 하는가? 등) 필요한 인수만 받는 함수를 만들도록 노력해봐야겠다.

### 많이 쓰는 단항 형식
1. 인수에 질문을 던지는 경우.
2. 인수를 뭔가로 변환하여 결과를 반환하는 경우.
3. 이벤트.

이러한 경우가 아니라면 단항 함수는 가급적 피하는 것이 좋다.

#### 플래그 인수
> 플래그의 존재 자체가 함수가 한꺼번에 여러 일을 처리한다는 의미이다.

플래그 인수로 처리되는 함수는 각 플래그마다 처리되는 함수를 분리하여 사용하는 것이 조금 더 이해하기 좋다.

### 이항 함수
이항 함수는 단항 함수보다 이해하기 힘들고 오해 소지가 많으므로 가능하다면 단항으로 바꾸는 것이 좋다.
### 삼항 함수
상동

### 인수 객체
> 인수가 많이 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.

객체를 생성해 인수를 줄이는 방법으로 인수에 들어가는 개념을 묶어 표현할 수 있게 되어 좋다.

### 인수 목록
때로는 인수 개수가 가변적인 함수도 필요하다. 가변 인수를 동등하게 취급하면 List 형 변수 하나로 취급할 수 있다.

### 동사와 키워드
> 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다.
- 단항 함수는 인수가 동사/명사 쌍을 이뤄야 한다.
``` js
// soso
write(name);

// good
writeField(name);
```
- 함수 이름에 키워드를 추가하면 인수 순서를 혼동하지 않을 수 있다.
``` js
// bad
assertEquals(expected, actural);

// good
assertExpectedEqualsActual(expected, actural);
```
---

## 부수 효과를 일으키지 마라!
> 부수 효과는 거짓말이다. 함수에서 한가지를 하겠다고 약속하고 남몰래 다른 동작을 수행하게 되면 큰 혼동을 가져온다.

부수 효과가 일어나면, 해석하기 더 어려워진다.

## 출력 인수
일반적으로 출력 인수는 피하는 것이 좋다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.

## 명령과 조회를 분리하라.
> 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.
한 가지 일만 수행해야 한다.

## 오류 코드보다 예외를 사용하라.
> 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위한한다. 자칫하며 if문에서 명령을 표현식으로 사용하기 쉬워진다.

### Try/Catch 블록 뽑아내기
> try/catch 블록은 정상 동작과 오류 처리 동작을 뒤섞어 코드 구조에 혼란을 준다. 따라서 별도의 블록을 함수로 뽑아내면 깔끔하게 표현 할 수 있다.

### 오류 처리도 한 가지 작업이다.
> 오류 처리도 작업이므로, 분리된 오류 처리 함수는 오류만 처리해야한다.

## 반복하지 마라. DRY
> 중복은 코드 길이를 늘릴 뿐만 아니라, 같은 동작을 수정할 때 지점도 많아져 번거로워지고, 깜빡할 수 있어 오류가 발생할 확률도 높아진다.

## 구조적 프로그래밍
> 함수와 함수 내 모든 불록에 입구와 출구가 하나만 존재해야 한다. 즉, 함수는 return 문이 하나여야 한다.
break, continue를 사용하면 안되며, goto 는 절대로 안된다.

저자도 목표에는 공감하지만 이러한 부분은 함수 크기를 충분히 줄인다면 해결 할 수 있는 문제라고 보았다.

## 함수를 어떻게 짜죠?
> 코드를 짜는 행위는 글짓기와 비슷하다. 처음부터 완벽하게 만들어지지 않기 때문에 먼저 짜고 지속적으로 읽기 좋게 다듬는 방법을 추천한다.

# 결론
- 작게 만들어라.
    - 작은 함수는 한 가지 일만 수행할 수 있다.
    - 한가지 일만 수행하게 되므로 이름을 짓기 쉬워진다.
    - 이름을 잘 지으면 코드을 이해하기 쉬워진다.
- 내려가기 규칙 - 일관된 추상화 수준을 유지해야 한다.
    - 한번에 한 단계씩 코드를 작게 분해하다 보면 일관된 추상화 수준을 유지하기 쉽다. 
